
// Generated from ./WGSL.txt by ANTLR 4.13.0


#include "WGSLListener.h"

#include "WGSLParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct WGSLParserStaticData final {
  WGSLParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  WGSLParserStaticData(const WGSLParserStaticData&) = delete;
  WGSLParserStaticData(WGSLParserStaticData&&) = delete;
  WGSLParserStaticData& operator=(const WGSLParserStaticData&) = delete;
  WGSLParserStaticData& operator=(WGSLParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag wgslParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
WGSLParserStaticData *wgslParserStaticData = nullptr;

void wgslParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (wgslParserStaticData != nullptr) {
    return;
  }
#else
  assert(wgslParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<WGSLParserStaticData>(
    std::vector<std::string>{
      "template_args_start", "template_args_end", "additive_operator", "multiplicative_operator", 
      "argument_expression_list", "assignment_statement", "shift_expression_post_unary_expression", 
      "attribute", "bitwise_expression_post_unary_expression", "case_selector", 
      "component_or_swizzle_specifier", "compound_statement", "core_lhs_expression", 
      "diagnostic_control", "diagnostic_rule_name", "expression", "float_literal", 
      "for_init", "for_update", "global_decl", "global_directive", "global_value_decl", 
      "ident", "int_literal", "lhs_expression", "literal", "member_ident", 
      "optionally_typed_ident", "param", "primary_expression", "greater_than", 
      "less_than", "relational_expression_post_unary_expression", "statement", 
      "switch_clause", "template_arg_expression", "template_elaborated_ident_post_ident", 
      "translation_unit", "type_specifier", "unary_expression", "variable_decl", 
      "variable_or_value_statement", "variable_updating_statement"
    },
    std::vector<std::string>{
      "", "'('", "','", "')'", "'='", "'@'", "'align'", "'binding'", "'builtin'", 
      "'compute'", "'const'", "'diagnostic'", "'fragment'", "'group'", "'id'", 
      "'interpolate'", "'invariant'", "'location'", "'must_use'", "'size'", 
      "'vertex'", "'workgroup_size'", "'&'", "'^'", "'|'", "'default'", 
      "'.'", "'['", "']'", "'{'", "'}'", "'&&'", "'||'", "'fn'", "':'", 
      "'->'", "'var'", "';'", "'alias'", "'const_assert'", "'struct'", "'enable'", 
      "'requires'", "'override'", "'!='", "'=='", "'for'", "'if'", "'else'", 
      "'loop'", "'continuing'", "'switch'", "'while'", "'discard'", "'return'", 
      "'case'", "'!'", "'~'", "'let'", "'++'", "'--'", "'_'", "", "'+'", 
      "'-'", "'*'", "'/'", "'%'", "'<'", "'>'", "", "", "", "", "", "", 
      "", "", "'>='", "'<='", "'<<'", "'>>'", "'break'", "'continue'"
    },
    std::vector<std::string>{
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "WS", "Positive", "Minus", 
      "Star", "Dash", "MOD", "Left_angle", "Right_angle", "Sigma_term", 
      "Ident_pattern_token", "Bool_literal", "Compound_assignment_operator", 
      "Decimal_float_literal", "Decimal_int_literal", "Hex_float_literal", 
      "Hex_int_literal", "Greater_than_equal", "Less_than_equal", "Shift_left", 
      "Shift_right", "Break_statement", "Continue_statement", "Severity_control_name", 
      "Swizzle_name"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,85,1023,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
  	14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
  	21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
  	28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,
  	35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,
  	42,1,0,1,0,1,1,1,1,1,2,1,2,1,3,1,3,1,4,1,4,1,4,1,4,5,4,99,8,4,10,4,12,
  	4,102,9,4,1,4,3,4,105,8,4,3,4,107,8,4,1,4,1,4,1,5,1,5,1,6,1,6,1,6,5,6,
  	116,8,6,10,6,12,6,119,9,6,1,6,1,6,1,6,1,6,1,6,5,6,126,8,6,10,6,12,6,129,
  	9,6,5,6,131,8,6,10,6,12,6,134,9,6,1,6,1,6,1,6,1,6,3,6,140,8,6,1,7,1,7,
  	1,7,1,7,1,7,3,7,147,8,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,156,8,7,1,7,1,
  	7,1,7,1,7,1,7,1,7,1,7,3,7,165,8,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,
  	1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,183,8,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,
  	7,192,8,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,201,8,7,1,7,1,7,1,7,1,7,1,7,
  	1,7,1,7,1,7,1,7,3,7,212,8,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,223,
  	8,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,234,8,7,1,7,1,7,1,7,1,7,1,
  	7,1,7,1,7,1,7,1,7,3,7,245,8,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,
  	256,8,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,269,8,7,1,7,1,
  	7,3,7,273,8,7,1,8,1,8,1,8,1,8,5,8,279,8,8,10,8,12,8,282,9,8,1,8,1,8,1,
  	8,1,8,5,8,288,8,8,10,8,12,8,291,9,8,1,8,1,8,1,8,1,8,5,8,297,8,8,10,8,
  	12,8,300,9,8,3,8,302,8,8,1,9,1,9,3,9,306,8,9,1,10,1,10,1,10,3,10,311,
  	8,10,1,10,1,10,1,10,3,10,316,8,10,1,10,1,10,1,10,1,10,3,10,322,8,10,3,
  	10,324,8,10,1,11,5,11,327,8,11,10,11,12,11,330,9,11,1,11,1,11,5,11,334,
  	8,11,10,11,12,11,337,9,11,1,11,1,11,1,12,1,12,1,12,1,12,1,12,3,12,346,
  	8,12,1,13,1,13,1,13,1,13,1,13,3,13,353,8,13,1,13,1,13,1,14,1,14,1,14,
  	1,14,3,14,361,8,14,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,
  	1,15,1,15,1,15,1,15,1,15,5,15,378,8,15,10,15,12,15,381,9,15,1,15,1,15,
  	1,15,1,15,1,15,1,15,1,15,1,15,1,15,5,15,392,8,15,10,15,12,15,395,9,15,
  	3,15,397,8,15,1,16,1,16,1,17,1,17,1,17,1,17,1,17,1,17,3,17,407,8,17,1,
  	18,1,18,1,18,1,18,1,18,3,18,414,8,18,1,19,5,19,417,8,19,10,19,12,19,420,
  	9,19,1,19,1,19,1,19,1,19,5,19,426,8,19,10,19,12,19,429,9,19,1,19,1,19,
  	1,19,1,19,1,19,5,19,436,8,19,10,19,12,19,439,9,19,1,19,3,19,442,8,19,
  	3,19,444,8,19,1,19,1,19,1,19,5,19,449,8,19,10,19,12,19,452,9,19,1,19,
  	1,19,1,19,3,19,457,8,19,1,19,5,19,460,8,19,10,19,12,19,463,9,19,1,19,
  	1,19,5,19,467,8,19,10,19,12,19,470,9,19,1,19,1,19,1,19,5,19,475,8,19,
  	10,19,12,19,478,9,19,1,19,1,19,1,19,1,19,1,19,5,19,485,8,19,10,19,12,
  	19,488,9,19,1,19,3,19,491,8,19,1,19,1,19,3,19,495,8,19,1,19,1,19,1,19,
  	3,19,500,8,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,
  	1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,5,19,523,8,19,10,19,
  	12,19,526,9,19,1,19,1,19,1,19,1,19,1,19,5,19,533,8,19,10,19,12,19,536,
  	9,19,1,19,1,19,1,19,1,19,5,19,542,8,19,10,19,12,19,545,9,19,1,19,3,19,
  	548,8,19,1,19,1,19,3,19,552,8,19,1,20,1,20,1,20,1,20,1,20,1,20,3,20,560,
  	8,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,5,20,569,8,20,10,20,12,20,572,
  	9,20,1,20,3,20,575,8,20,1,20,1,20,1,20,1,20,1,20,5,20,582,8,20,10,20,
  	12,20,585,9,20,1,20,3,20,588,8,20,1,20,3,20,591,8,20,1,21,5,21,594,8,
  	21,10,21,12,21,597,9,21,1,21,1,21,1,21,1,21,3,21,603,8,21,1,21,1,21,1,
  	21,1,21,1,21,3,21,610,8,21,1,22,1,22,1,23,1,23,1,24,1,24,3,24,618,8,24,
  	1,24,1,24,1,24,1,24,3,24,624,8,24,1,25,1,25,1,25,3,25,629,8,25,1,26,1,
  	26,1,27,1,27,1,27,3,27,636,8,27,1,28,5,28,639,8,28,10,28,12,28,642,9,
  	28,1,28,1,28,1,28,1,28,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,1,29,5,
  	29,657,8,29,10,29,12,29,660,9,29,1,29,3,29,663,8,29,3,29,665,8,29,1,29,
  	1,29,1,29,1,29,1,29,1,29,1,29,3,29,674,8,29,1,30,1,30,1,31,1,31,1,32,
  	1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,
  	1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,
  	1,32,1,32,3,32,711,8,32,1,33,5,33,714,8,33,10,33,12,33,717,9,33,1,33,
  	1,33,1,33,3,33,722,8,33,1,33,1,33,3,33,726,8,33,1,33,1,33,3,33,730,8,
  	33,1,33,1,33,1,33,5,33,735,8,33,10,33,12,33,738,9,33,1,33,1,33,1,33,1,
  	33,1,33,1,33,1,33,1,33,5,33,748,8,33,10,33,12,33,751,9,33,1,33,1,33,3,
  	33,755,8,33,1,33,5,33,758,8,33,10,33,12,33,761,9,33,1,33,1,33,5,33,765,
  	8,33,10,33,12,33,768,9,33,1,33,1,33,5,33,772,8,33,10,33,12,33,775,9,33,
  	1,33,1,33,5,33,779,8,33,10,33,12,33,782,9,33,1,33,1,33,5,33,786,8,33,
  	10,33,12,33,789,9,33,1,33,1,33,1,33,1,33,1,33,3,33,796,8,33,1,33,3,33,
  	799,8,33,1,33,1,33,5,33,803,8,33,10,33,12,33,806,9,33,1,33,1,33,1,33,
  	5,33,811,8,33,10,33,12,33,814,9,33,1,33,1,33,5,33,818,8,33,10,33,12,33,
  	821,9,33,1,33,1,33,1,33,5,33,826,8,33,10,33,12,33,829,9,33,1,33,1,33,
  	1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,5,33,842,8,33,10,33,12,33,
  	845,9,33,1,33,3,33,848,8,33,3,33,850,8,33,1,33,1,33,1,33,1,33,1,33,1,
  	33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,33,1,
  	33,1,33,1,33,3,33,874,8,33,1,33,3,33,877,8,33,1,34,1,34,1,34,1,34,5,34,
  	883,8,34,10,34,12,34,886,9,34,1,34,3,34,889,8,34,1,34,3,34,892,8,34,1,
  	34,1,34,1,34,1,34,3,34,898,8,34,1,34,3,34,901,8,34,1,35,1,35,1,36,1,36,
  	1,36,1,36,5,36,909,8,36,10,36,12,36,912,9,36,1,36,3,36,915,8,36,1,36,
  	1,36,3,36,919,8,36,1,37,5,37,922,8,37,10,37,12,37,925,9,37,1,37,5,37,
  	928,8,37,10,37,12,37,931,9,37,1,37,5,37,934,8,37,10,37,12,37,937,9,37,
  	1,38,1,38,1,38,1,38,1,38,5,38,944,8,38,10,38,12,38,947,9,38,1,38,3,38,
  	950,8,38,1,38,1,38,3,38,954,8,38,1,39,1,39,3,39,958,8,39,1,39,1,39,1,
  	39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,3,39,970,8,39,1,40,1,40,1,40,1,
  	40,1,40,5,40,977,8,40,10,40,12,40,980,9,40,1,40,3,40,983,8,40,1,40,1,
  	40,3,40,987,8,40,1,40,1,40,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,41,1,
  	41,1,41,1,41,1,41,1,41,1,41,1,41,3,41,1006,8,41,1,42,1,42,1,42,1,42,1,
  	42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,3,42,1021,8,42,1,42,0,0,43,
  	0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,
  	50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,0,6,1,0,63,64,1,
  	0,65,67,2,0,4,4,73,73,2,0,74,74,76,76,1,0,70,71,2,0,75,75,77,77,1159,
  	0,86,1,0,0,0,2,88,1,0,0,0,4,90,1,0,0,0,6,92,1,0,0,0,8,94,1,0,0,0,10,110,
  	1,0,0,0,12,139,1,0,0,0,14,272,1,0,0,0,16,301,1,0,0,0,18,305,1,0,0,0,20,
  	323,1,0,0,0,22,328,1,0,0,0,24,345,1,0,0,0,26,347,1,0,0,0,28,360,1,0,0,
  	0,30,396,1,0,0,0,32,398,1,0,0,0,34,406,1,0,0,0,36,413,1,0,0,0,38,551,
  	1,0,0,0,40,590,1,0,0,0,42,609,1,0,0,0,44,611,1,0,0,0,46,613,1,0,0,0,48,
  	623,1,0,0,0,50,628,1,0,0,0,52,630,1,0,0,0,54,632,1,0,0,0,56,640,1,0,0,
  	0,58,673,1,0,0,0,60,675,1,0,0,0,62,677,1,0,0,0,64,710,1,0,0,0,66,876,
  	1,0,0,0,68,900,1,0,0,0,70,902,1,0,0,0,72,918,1,0,0,0,74,923,1,0,0,0,76,
  	938,1,0,0,0,78,969,1,0,0,0,80,971,1,0,0,0,82,1005,1,0,0,0,84,1020,1,0,
  	0,0,86,87,5,68,0,0,87,1,1,0,0,0,88,89,5,69,0,0,89,3,1,0,0,0,90,91,7,0,
  	0,0,91,5,1,0,0,0,92,93,7,1,0,0,93,7,1,0,0,0,94,106,5,1,0,0,95,100,3,30,
  	15,0,96,97,5,2,0,0,97,99,3,30,15,0,98,96,1,0,0,0,99,102,1,0,0,0,100,98,
  	1,0,0,0,100,101,1,0,0,0,101,104,1,0,0,0,102,100,1,0,0,0,103,105,5,2,0,
  	0,104,103,1,0,0,0,104,105,1,0,0,0,105,107,1,0,0,0,106,95,1,0,0,0,106,
  	107,1,0,0,0,107,108,1,0,0,0,108,109,5,3,0,0,109,9,1,0,0,0,110,111,7,2,
  	0,0,111,11,1,0,0,0,112,113,3,6,3,0,113,114,3,78,39,0,114,116,1,0,0,0,
  	115,112,1,0,0,0,116,119,1,0,0,0,117,115,1,0,0,0,117,118,1,0,0,0,118,132,
  	1,0,0,0,119,117,1,0,0,0,120,121,3,4,2,0,121,127,3,78,39,0,122,123,3,6,
  	3,0,123,124,3,78,39,0,124,126,1,0,0,0,125,122,1,0,0,0,126,129,1,0,0,0,
  	127,125,1,0,0,0,127,128,1,0,0,0,128,131,1,0,0,0,129,127,1,0,0,0,130,120,
  	1,0,0,0,131,134,1,0,0,0,132,130,1,0,0,0,132,133,1,0,0,0,133,140,1,0,0,
  	0,134,132,1,0,0,0,135,136,5,80,0,0,136,140,3,78,39,0,137,138,5,81,0,0,
  	138,140,3,78,39,0,139,117,1,0,0,0,139,135,1,0,0,0,139,137,1,0,0,0,140,
  	13,1,0,0,0,141,142,5,5,0,0,142,143,5,6,0,0,143,144,5,1,0,0,144,146,3,
  	30,15,0,145,147,5,2,0,0,146,145,1,0,0,0,146,147,1,0,0,0,147,148,1,0,0,
  	0,148,149,5,3,0,0,149,273,1,0,0,0,150,151,5,5,0,0,151,152,5,7,0,0,152,
  	153,5,1,0,0,153,155,3,30,15,0,154,156,5,2,0,0,155,154,1,0,0,0,155,156,
  	1,0,0,0,156,157,1,0,0,0,157,158,5,3,0,0,158,273,1,0,0,0,159,160,5,5,0,
  	0,160,161,5,8,0,0,161,162,5,1,0,0,162,164,3,30,15,0,163,165,5,2,0,0,164,
  	163,1,0,0,0,164,165,1,0,0,0,165,166,1,0,0,0,166,167,5,3,0,0,167,273,1,
  	0,0,0,168,169,5,5,0,0,169,273,5,9,0,0,170,171,5,5,0,0,171,273,5,10,0,
  	0,172,173,5,5,0,0,173,174,5,11,0,0,174,273,3,26,13,0,175,176,5,5,0,0,
  	176,273,5,12,0,0,177,178,5,5,0,0,178,179,5,13,0,0,179,180,5,1,0,0,180,
  	182,3,30,15,0,181,183,5,2,0,0,182,181,1,0,0,0,182,183,1,0,0,0,183,184,
  	1,0,0,0,184,185,5,3,0,0,185,273,1,0,0,0,186,187,5,5,0,0,187,188,5,14,
  	0,0,188,189,5,1,0,0,189,191,3,30,15,0,190,192,5,2,0,0,191,190,1,0,0,0,
  	191,192,1,0,0,0,192,193,1,0,0,0,193,194,5,3,0,0,194,273,1,0,0,0,195,196,
  	5,5,0,0,196,197,5,15,0,0,197,198,5,1,0,0,198,200,3,30,15,0,199,201,5,
  	2,0,0,200,199,1,0,0,0,200,201,1,0,0,0,201,202,1,0,0,0,202,203,5,3,0,0,
  	203,273,1,0,0,0,204,205,5,5,0,0,205,206,5,15,0,0,206,207,5,1,0,0,207,
  	208,3,30,15,0,208,209,5,2,0,0,209,211,3,30,15,0,210,212,5,2,0,0,211,210,
  	1,0,0,0,211,212,1,0,0,0,212,213,1,0,0,0,213,214,5,3,0,0,214,273,1,0,0,
  	0,215,216,5,5,0,0,216,273,5,16,0,0,217,218,5,5,0,0,218,219,5,17,0,0,219,
  	220,5,1,0,0,220,222,3,30,15,0,221,223,5,2,0,0,222,221,1,0,0,0,222,223,
  	1,0,0,0,223,224,1,0,0,0,224,225,5,3,0,0,225,273,1,0,0,0,226,227,5,5,0,
  	0,227,273,5,18,0,0,228,229,5,5,0,0,229,230,5,19,0,0,230,231,5,1,0,0,231,
  	233,3,30,15,0,232,234,5,2,0,0,233,232,1,0,0,0,233,234,1,0,0,0,234,235,
  	1,0,0,0,235,236,5,3,0,0,236,273,1,0,0,0,237,238,5,5,0,0,238,273,5,20,
  	0,0,239,240,5,5,0,0,240,241,5,21,0,0,241,242,5,1,0,0,242,244,3,30,15,
  	0,243,245,5,2,0,0,244,243,1,0,0,0,244,245,1,0,0,0,245,246,1,0,0,0,246,
  	247,5,3,0,0,247,273,1,0,0,0,248,249,5,5,0,0,249,250,5,21,0,0,250,251,
  	5,1,0,0,251,252,3,30,15,0,252,253,5,2,0,0,253,255,3,30,15,0,254,256,5,
  	2,0,0,255,254,1,0,0,0,255,256,1,0,0,0,256,257,1,0,0,0,257,258,5,3,0,0,
  	258,273,1,0,0,0,259,260,5,5,0,0,260,261,5,21,0,0,261,262,5,1,0,0,262,
  	263,3,30,15,0,263,264,5,2,0,0,264,265,3,30,15,0,265,266,5,2,0,0,266,268,
  	3,30,15,0,267,269,5,2,0,0,268,267,1,0,0,0,268,269,1,0,0,0,269,270,1,0,
  	0,0,270,271,5,3,0,0,271,273,1,0,0,0,272,141,1,0,0,0,272,150,1,0,0,0,272,
  	159,1,0,0,0,272,168,1,0,0,0,272,170,1,0,0,0,272,172,1,0,0,0,272,175,1,
  	0,0,0,272,177,1,0,0,0,272,186,1,0,0,0,272,195,1,0,0,0,272,204,1,0,0,0,
  	272,215,1,0,0,0,272,217,1,0,0,0,272,226,1,0,0,0,272,228,1,0,0,0,272,237,
  	1,0,0,0,272,239,1,0,0,0,272,248,1,0,0,0,272,259,1,0,0,0,273,15,1,0,0,
  	0,274,275,5,22,0,0,275,280,3,78,39,0,276,277,5,22,0,0,277,279,3,78,39,
  	0,278,276,1,0,0,0,279,282,1,0,0,0,280,278,1,0,0,0,280,281,1,0,0,0,281,
  	302,1,0,0,0,282,280,1,0,0,0,283,284,5,23,0,0,284,289,3,78,39,0,285,286,
  	5,23,0,0,286,288,3,78,39,0,287,285,1,0,0,0,288,291,1,0,0,0,289,287,1,
  	0,0,0,289,290,1,0,0,0,290,302,1,0,0,0,291,289,1,0,0,0,292,293,5,24,0,
  	0,293,298,3,78,39,0,294,295,5,24,0,0,295,297,3,78,39,0,296,294,1,0,0,
  	0,297,300,1,0,0,0,298,296,1,0,0,0,298,299,1,0,0,0,299,302,1,0,0,0,300,
  	298,1,0,0,0,301,274,1,0,0,0,301,283,1,0,0,0,301,292,1,0,0,0,302,17,1,
  	0,0,0,303,306,3,30,15,0,304,306,5,25,0,0,305,303,1,0,0,0,305,304,1,0,
  	0,0,306,19,1,0,0,0,307,308,5,26,0,0,308,310,3,52,26,0,309,311,3,20,10,
  	0,310,309,1,0,0,0,310,311,1,0,0,0,311,324,1,0,0,0,312,313,5,26,0,0,313,
  	315,5,85,0,0,314,316,3,20,10,0,315,314,1,0,0,0,315,316,1,0,0,0,316,324,
  	1,0,0,0,317,318,5,27,0,0,318,319,3,30,15,0,319,321,5,28,0,0,320,322,3,
  	20,10,0,321,320,1,0,0,0,321,322,1,0,0,0,322,324,1,0,0,0,323,307,1,0,0,
  	0,323,312,1,0,0,0,323,317,1,0,0,0,324,21,1,0,0,0,325,327,3,14,7,0,326,
  	325,1,0,0,0,327,330,1,0,0,0,328,326,1,0,0,0,328,329,1,0,0,0,329,331,1,
  	0,0,0,330,328,1,0,0,0,331,335,5,29,0,0,332,334,3,66,33,0,333,332,1,0,
  	0,0,334,337,1,0,0,0,335,333,1,0,0,0,335,336,1,0,0,0,336,338,1,0,0,0,337,
  	335,1,0,0,0,338,339,5,30,0,0,339,23,1,0,0,0,340,346,3,44,22,0,341,342,
  	5,1,0,0,342,343,3,48,24,0,343,344,5,3,0,0,344,346,1,0,0,0,345,340,1,0,
  	0,0,345,341,1,0,0,0,346,25,1,0,0,0,347,348,5,1,0,0,348,349,5,84,0,0,349,
  	350,5,2,0,0,350,352,3,28,14,0,351,353,5,2,0,0,352,351,1,0,0,0,352,353,
  	1,0,0,0,353,354,1,0,0,0,354,355,5,3,0,0,355,27,1,0,0,0,356,361,5,71,0,
  	0,357,358,5,71,0,0,358,359,5,26,0,0,359,361,5,71,0,0,360,356,1,0,0,0,
  	360,357,1,0,0,0,361,29,1,0,0,0,362,363,3,78,39,0,363,364,3,16,8,0,364,
  	397,1,0,0,0,365,366,3,78,39,0,366,367,3,64,32,0,367,397,1,0,0,0,368,369,
  	3,78,39,0,369,370,3,64,32,0,370,371,5,31,0,0,371,372,3,78,39,0,372,379,
  	3,64,32,0,373,374,5,31,0,0,374,375,3,78,39,0,375,376,3,64,32,0,376,378,
  	1,0,0,0,377,373,1,0,0,0,378,381,1,0,0,0,379,377,1,0,0,0,379,380,1,0,0,
  	0,380,397,1,0,0,0,381,379,1,0,0,0,382,383,3,78,39,0,383,384,3,64,32,0,
  	384,385,5,32,0,0,385,386,3,78,39,0,386,393,3,64,32,0,387,388,5,32,0,0,
  	388,389,3,78,39,0,389,390,3,64,32,0,390,392,1,0,0,0,391,387,1,0,0,0,392,
  	395,1,0,0,0,393,391,1,0,0,0,393,394,1,0,0,0,394,397,1,0,0,0,395,393,1,
  	0,0,0,396,362,1,0,0,0,396,365,1,0,0,0,396,368,1,0,0,0,396,382,1,0,0,0,
  	397,31,1,0,0,0,398,399,7,3,0,0,399,33,1,0,0,0,400,401,3,44,22,0,401,402,
  	3,72,36,0,402,403,3,8,4,0,403,407,1,0,0,0,404,407,3,82,41,0,405,407,3,
  	84,42,0,406,400,1,0,0,0,406,404,1,0,0,0,406,405,1,0,0,0,407,35,1,0,0,
  	0,408,409,3,44,22,0,409,410,3,72,36,0,410,411,3,8,4,0,411,414,1,0,0,0,
  	412,414,3,84,42,0,413,408,1,0,0,0,413,412,1,0,0,0,414,37,1,0,0,0,415,
  	417,3,14,7,0,416,415,1,0,0,0,417,420,1,0,0,0,418,416,1,0,0,0,418,419,
  	1,0,0,0,419,421,1,0,0,0,420,418,1,0,0,0,421,422,5,33,0,0,422,423,3,44,
  	22,0,423,443,5,1,0,0,424,426,3,14,7,0,425,424,1,0,0,0,426,429,1,0,0,0,
  	427,425,1,0,0,0,427,428,1,0,0,0,428,430,1,0,0,0,429,427,1,0,0,0,430,431,
  	3,44,22,0,431,432,5,34,0,0,432,437,3,76,38,0,433,434,5,2,0,0,434,436,
  	3,56,28,0,435,433,1,0,0,0,436,439,1,0,0,0,437,435,1,0,0,0,437,438,1,0,
  	0,0,438,441,1,0,0,0,439,437,1,0,0,0,440,442,5,2,0,0,441,440,1,0,0,0,441,
  	442,1,0,0,0,442,444,1,0,0,0,443,427,1,0,0,0,443,444,1,0,0,0,444,445,1,
  	0,0,0,445,456,5,3,0,0,446,450,5,35,0,0,447,449,3,14,7,0,448,447,1,0,0,
  	0,449,452,1,0,0,0,450,448,1,0,0,0,450,451,1,0,0,0,451,453,1,0,0,0,452,
  	450,1,0,0,0,453,454,3,44,22,0,454,455,3,72,36,0,455,457,1,0,0,0,456,446,
  	1,0,0,0,456,457,1,0,0,0,457,461,1,0,0,0,458,460,3,14,7,0,459,458,1,0,
  	0,0,460,463,1,0,0,0,461,459,1,0,0,0,461,462,1,0,0,0,462,464,1,0,0,0,463,
  	461,1,0,0,0,464,468,5,29,0,0,465,467,3,66,33,0,466,465,1,0,0,0,467,470,
  	1,0,0,0,468,466,1,0,0,0,468,469,1,0,0,0,469,471,1,0,0,0,470,468,1,0,0,
  	0,471,472,5,30,0,0,472,552,1,0,0,0,473,475,3,14,7,0,474,473,1,0,0,0,475,
  	478,1,0,0,0,476,474,1,0,0,0,476,477,1,0,0,0,477,479,1,0,0,0,478,476,1,
  	0,0,0,479,494,5,36,0,0,480,481,3,0,0,0,481,486,3,30,15,0,482,483,5,2,
  	0,0,483,485,3,30,15,0,484,482,1,0,0,0,485,488,1,0,0,0,486,484,1,0,0,0,
  	486,487,1,0,0,0,487,490,1,0,0,0,488,486,1,0,0,0,489,491,5,2,0,0,490,489,
  	1,0,0,0,490,491,1,0,0,0,491,492,1,0,0,0,492,493,3,2,1,0,493,495,1,0,0,
  	0,494,480,1,0,0,0,494,495,1,0,0,0,495,496,1,0,0,0,496,499,3,54,27,0,497,
  	498,5,4,0,0,498,500,3,30,15,0,499,497,1,0,0,0,499,500,1,0,0,0,500,501,
  	1,0,0,0,501,502,5,37,0,0,502,552,1,0,0,0,503,504,3,42,21,0,504,505,5,
  	37,0,0,505,552,1,0,0,0,506,552,5,37,0,0,507,508,5,38,0,0,508,509,3,44,
  	22,0,509,510,5,4,0,0,510,511,3,44,22,0,511,512,3,72,36,0,512,513,5,37,
  	0,0,513,552,1,0,0,0,514,515,5,39,0,0,515,516,3,30,15,0,516,517,5,37,0,
  	0,517,552,1,0,0,0,518,519,5,40,0,0,519,520,3,44,22,0,520,524,5,29,0,0,
  	521,523,3,14,7,0,522,521,1,0,0,0,523,526,1,0,0,0,524,522,1,0,0,0,524,
  	525,1,0,0,0,525,527,1,0,0,0,526,524,1,0,0,0,527,528,3,52,26,0,528,529,
  	5,34,0,0,529,543,3,76,38,0,530,534,5,2,0,0,531,533,3,14,7,0,532,531,1,
  	0,0,0,533,536,1,0,0,0,534,532,1,0,0,0,534,535,1,0,0,0,535,537,1,0,0,0,
  	536,534,1,0,0,0,537,538,3,52,26,0,538,539,5,34,0,0,539,540,3,76,38,0,
  	540,542,1,0,0,0,541,530,1,0,0,0,542,545,1,0,0,0,543,541,1,0,0,0,543,544,
  	1,0,0,0,544,547,1,0,0,0,545,543,1,0,0,0,546,548,5,2,0,0,547,546,1,0,0,
  	0,547,548,1,0,0,0,548,549,1,0,0,0,549,550,5,30,0,0,550,552,1,0,0,0,551,
  	418,1,0,0,0,551,476,1,0,0,0,551,503,1,0,0,0,551,506,1,0,0,0,551,507,1,
  	0,0,0,551,514,1,0,0,0,551,518,1,0,0,0,552,39,1,0,0,0,553,554,5,11,0,0,
  	554,555,5,1,0,0,555,556,5,84,0,0,556,557,5,2,0,0,557,559,3,28,14,0,558,
  	560,5,2,0,0,559,558,1,0,0,0,559,560,1,0,0,0,560,561,1,0,0,0,561,562,5,
  	3,0,0,562,563,5,37,0,0,563,591,1,0,0,0,564,565,5,41,0,0,565,570,5,71,
  	0,0,566,567,5,2,0,0,567,569,5,71,0,0,568,566,1,0,0,0,569,572,1,0,0,0,
  	570,568,1,0,0,0,570,571,1,0,0,0,571,574,1,0,0,0,572,570,1,0,0,0,573,575,
  	5,2,0,0,574,573,1,0,0,0,574,575,1,0,0,0,575,576,1,0,0,0,576,591,5,37,
  	0,0,577,578,5,42,0,0,578,583,5,71,0,0,579,580,5,2,0,0,580,582,5,71,0,
  	0,581,579,1,0,0,0,582,585,1,0,0,0,583,581,1,0,0,0,583,584,1,0,0,0,584,
  	587,1,0,0,0,585,583,1,0,0,0,586,588,5,2,0,0,587,586,1,0,0,0,587,588,1,
  	0,0,0,588,589,1,0,0,0,589,591,5,37,0,0,590,553,1,0,0,0,590,564,1,0,0,
  	0,590,577,1,0,0,0,591,41,1,0,0,0,592,594,3,14,7,0,593,592,1,0,0,0,594,
  	597,1,0,0,0,595,593,1,0,0,0,595,596,1,0,0,0,596,598,1,0,0,0,597,595,1,
  	0,0,0,598,599,5,43,0,0,599,602,3,54,27,0,600,601,5,4,0,0,601,603,3,30,
  	15,0,602,600,1,0,0,0,602,603,1,0,0,0,603,610,1,0,0,0,604,605,5,10,0,0,
  	605,606,3,54,27,0,606,607,5,4,0,0,607,608,3,30,15,0,608,610,1,0,0,0,609,
  	595,1,0,0,0,609,604,1,0,0,0,610,43,1,0,0,0,611,612,7,4,0,0,612,45,1,0,
  	0,0,613,614,7,5,0,0,614,47,1,0,0,0,615,617,3,24,12,0,616,618,3,20,10,
  	0,617,616,1,0,0,0,617,618,1,0,0,0,618,624,1,0,0,0,619,620,5,22,0,0,620,
  	624,3,48,24,0,621,622,5,65,0,0,622,624,3,48,24,0,623,615,1,0,0,0,623,
  	619,1,0,0,0,623,621,1,0,0,0,624,49,1,0,0,0,625,629,5,72,0,0,626,629,3,
  	32,16,0,627,629,3,46,23,0,628,625,1,0,0,0,628,626,1,0,0,0,628,627,1,0,
  	0,0,629,51,1,0,0,0,630,631,5,71,0,0,631,53,1,0,0,0,632,635,3,44,22,0,
  	633,634,5,34,0,0,634,636,3,76,38,0,635,633,1,0,0,0,635,636,1,0,0,0,636,
  	55,1,0,0,0,637,639,3,14,7,0,638,637,1,0,0,0,639,642,1,0,0,0,640,638,1,
  	0,0,0,640,641,1,0,0,0,641,643,1,0,0,0,642,640,1,0,0,0,643,644,3,44,22,
  	0,644,645,5,34,0,0,645,646,3,76,38,0,646,57,1,0,0,0,647,648,3,44,22,0,
  	648,649,3,72,36,0,649,674,1,0,0,0,650,651,3,44,22,0,651,652,3,72,36,0,
  	652,664,5,1,0,0,653,658,3,30,15,0,654,655,5,2,0,0,655,657,3,30,15,0,656,
  	654,1,0,0,0,657,660,1,0,0,0,658,656,1,0,0,0,658,659,1,0,0,0,659,662,1,
  	0,0,0,660,658,1,0,0,0,661,663,5,2,0,0,662,661,1,0,0,0,662,663,1,0,0,0,
  	663,665,1,0,0,0,664,653,1,0,0,0,664,665,1,0,0,0,665,666,1,0,0,0,666,667,
  	5,3,0,0,667,674,1,0,0,0,668,674,3,50,25,0,669,670,5,1,0,0,670,671,3,30,
  	15,0,671,672,5,3,0,0,672,674,1,0,0,0,673,647,1,0,0,0,673,650,1,0,0,0,
  	673,668,1,0,0,0,673,669,1,0,0,0,674,59,1,0,0,0,675,676,5,69,0,0,676,61,
  	1,0,0,0,677,678,5,68,0,0,678,63,1,0,0,0,679,711,3,12,6,0,680,681,3,12,
  	6,0,681,682,3,60,30,0,682,683,3,78,39,0,683,684,3,12,6,0,684,711,1,0,
  	0,0,685,686,3,12,6,0,686,687,5,78,0,0,687,688,3,78,39,0,688,689,3,12,
  	6,0,689,711,1,0,0,0,690,691,3,12,6,0,691,692,3,62,31,0,692,693,3,78,39,
  	0,693,694,3,12,6,0,694,711,1,0,0,0,695,696,3,12,6,0,696,697,5,79,0,0,
  	697,698,3,78,39,0,698,699,3,12,6,0,699,711,1,0,0,0,700,701,3,12,6,0,701,
  	702,5,44,0,0,702,703,3,78,39,0,703,704,3,12,6,0,704,711,1,0,0,0,705,706,
  	3,12,6,0,706,707,5,45,0,0,707,708,3,78,39,0,708,709,3,12,6,0,709,711,
  	1,0,0,0,710,679,1,0,0,0,710,680,1,0,0,0,710,685,1,0,0,0,710,690,1,0,0,
  	0,710,695,1,0,0,0,710,700,1,0,0,0,710,705,1,0,0,0,711,65,1,0,0,0,712,
  	714,3,14,7,0,713,712,1,0,0,0,714,717,1,0,0,0,715,713,1,0,0,0,715,716,
  	1,0,0,0,716,718,1,0,0,0,717,715,1,0,0,0,718,719,5,46,0,0,719,721,5,1,
  	0,0,720,722,3,34,17,0,721,720,1,0,0,0,721,722,1,0,0,0,722,723,1,0,0,0,
  	723,725,5,37,0,0,724,726,3,30,15,0,725,724,1,0,0,0,725,726,1,0,0,0,726,
  	727,1,0,0,0,727,729,5,37,0,0,728,730,3,36,18,0,729,728,1,0,0,0,729,730,
  	1,0,0,0,730,731,1,0,0,0,731,732,5,3,0,0,732,877,3,22,11,0,733,735,3,14,
  	7,0,734,733,1,0,0,0,735,738,1,0,0,0,736,734,1,0,0,0,736,737,1,0,0,0,737,
  	739,1,0,0,0,738,736,1,0,0,0,739,740,5,47,0,0,740,741,3,30,15,0,741,749,
  	3,22,11,0,742,743,5,48,0,0,743,744,5,47,0,0,744,745,3,30,15,0,745,746,
  	3,22,11,0,746,748,1,0,0,0,747,742,1,0,0,0,748,751,1,0,0,0,749,747,1,0,
  	0,0,749,750,1,0,0,0,750,754,1,0,0,0,751,749,1,0,0,0,752,753,5,48,0,0,
  	753,755,3,22,11,0,754,752,1,0,0,0,754,755,1,0,0,0,755,877,1,0,0,0,756,
  	758,3,14,7,0,757,756,1,0,0,0,758,761,1,0,0,0,759,757,1,0,0,0,759,760,
  	1,0,0,0,760,762,1,0,0,0,761,759,1,0,0,0,762,766,5,49,0,0,763,765,3,14,
  	7,0,764,763,1,0,0,0,765,768,1,0,0,0,766,764,1,0,0,0,766,767,1,0,0,0,767,
  	769,1,0,0,0,768,766,1,0,0,0,769,773,5,29,0,0,770,772,3,66,33,0,771,770,
  	1,0,0,0,772,775,1,0,0,0,773,771,1,0,0,0,773,774,1,0,0,0,774,798,1,0,0,
  	0,775,773,1,0,0,0,776,780,5,50,0,0,777,779,3,14,7,0,778,777,1,0,0,0,779,
  	782,1,0,0,0,780,778,1,0,0,0,780,781,1,0,0,0,781,783,1,0,0,0,782,780,1,
  	0,0,0,783,787,5,29,0,0,784,786,3,66,33,0,785,784,1,0,0,0,786,789,1,0,
  	0,0,787,785,1,0,0,0,787,788,1,0,0,0,788,795,1,0,0,0,789,787,1,0,0,0,790,
  	791,5,82,0,0,791,792,5,47,0,0,792,793,3,30,15,0,793,794,5,37,0,0,794,
  	796,1,0,0,0,795,790,1,0,0,0,795,796,1,0,0,0,796,797,1,0,0,0,797,799,5,
  	30,0,0,798,776,1,0,0,0,798,799,1,0,0,0,799,800,1,0,0,0,800,877,5,30,0,
  	0,801,803,3,14,7,0,802,801,1,0,0,0,803,806,1,0,0,0,804,802,1,0,0,0,804,
  	805,1,0,0,0,805,807,1,0,0,0,806,804,1,0,0,0,807,808,5,51,0,0,808,812,
  	3,30,15,0,809,811,3,14,7,0,810,809,1,0,0,0,811,814,1,0,0,0,812,810,1,
  	0,0,0,812,813,1,0,0,0,813,815,1,0,0,0,814,812,1,0,0,0,815,819,5,29,0,
  	0,816,818,3,68,34,0,817,816,1,0,0,0,818,821,1,0,0,0,819,817,1,0,0,0,819,
  	820,1,0,0,0,820,822,1,0,0,0,821,819,1,0,0,0,822,823,5,30,0,0,823,877,
  	1,0,0,0,824,826,3,14,7,0,825,824,1,0,0,0,826,829,1,0,0,0,827,825,1,0,
  	0,0,827,828,1,0,0,0,828,830,1,0,0,0,829,827,1,0,0,0,830,831,5,52,0,0,
  	831,832,3,30,15,0,832,833,3,22,11,0,833,877,1,0,0,0,834,877,3,22,11,0,
  	835,836,3,44,22,0,836,837,3,72,36,0,837,849,5,1,0,0,838,843,3,30,15,0,
  	839,840,5,2,0,0,840,842,3,30,15,0,841,839,1,0,0,0,842,845,1,0,0,0,843,
  	841,1,0,0,0,843,844,1,0,0,0,844,847,1,0,0,0,845,843,1,0,0,0,846,848,5,
  	2,0,0,847,846,1,0,0,0,847,848,1,0,0,0,848,850,1,0,0,0,849,838,1,0,0,0,
  	849,850,1,0,0,0,850,851,1,0,0,0,851,852,5,3,0,0,852,853,5,37,0,0,853,
  	877,1,0,0,0,854,855,3,82,41,0,855,856,5,37,0,0,856,877,1,0,0,0,857,858,
  	3,84,42,0,858,859,5,37,0,0,859,877,1,0,0,0,860,861,5,82,0,0,861,877,5,
  	37,0,0,862,863,5,83,0,0,863,877,5,37,0,0,864,877,5,37,0,0,865,866,5,39,
  	0,0,866,867,3,30,15,0,867,868,5,37,0,0,868,877,1,0,0,0,869,870,5,53,0,
  	0,870,877,5,37,0,0,871,873,5,54,0,0,872,874,3,30,15,0,873,872,1,0,0,0,
  	873,874,1,0,0,0,874,875,1,0,0,0,875,877,5,37,0,0,876,715,1,0,0,0,876,
  	736,1,0,0,0,876,759,1,0,0,0,876,804,1,0,0,0,876,827,1,0,0,0,876,834,1,
  	0,0,0,876,835,1,0,0,0,876,854,1,0,0,0,876,857,1,0,0,0,876,860,1,0,0,0,
  	876,862,1,0,0,0,876,864,1,0,0,0,876,865,1,0,0,0,876,869,1,0,0,0,876,871,
  	1,0,0,0,877,67,1,0,0,0,878,879,5,55,0,0,879,884,3,18,9,0,880,881,5,2,
  	0,0,881,883,3,18,9,0,882,880,1,0,0,0,883,886,1,0,0,0,884,882,1,0,0,0,
  	884,885,1,0,0,0,885,888,1,0,0,0,886,884,1,0,0,0,887,889,5,2,0,0,888,887,
  	1,0,0,0,888,889,1,0,0,0,889,891,1,0,0,0,890,892,5,34,0,0,891,890,1,0,
  	0,0,891,892,1,0,0,0,892,893,1,0,0,0,893,894,3,22,11,0,894,901,1,0,0,0,
  	895,897,5,25,0,0,896,898,5,34,0,0,897,896,1,0,0,0,897,898,1,0,0,0,898,
  	899,1,0,0,0,899,901,3,22,11,0,900,878,1,0,0,0,900,895,1,0,0,0,901,69,
  	1,0,0,0,902,903,3,30,15,0,903,71,1,0,0,0,904,905,3,0,0,0,905,910,3,70,
  	35,0,906,907,5,2,0,0,907,909,3,30,15,0,908,906,1,0,0,0,909,912,1,0,0,
  	0,910,908,1,0,0,0,910,911,1,0,0,0,911,914,1,0,0,0,912,910,1,0,0,0,913,
  	915,5,2,0,0,914,913,1,0,0,0,914,915,1,0,0,0,915,916,1,0,0,0,916,917,3,
  	2,1,0,917,919,1,0,0,0,918,904,1,0,0,0,918,919,1,0,0,0,919,73,1,0,0,0,
  	920,922,3,40,20,0,921,920,1,0,0,0,922,925,1,0,0,0,923,921,1,0,0,0,923,
  	924,1,0,0,0,924,929,1,0,0,0,925,923,1,0,0,0,926,928,3,38,19,0,927,926,
  	1,0,0,0,928,931,1,0,0,0,929,927,1,0,0,0,929,930,1,0,0,0,930,935,1,0,0,
  	0,931,929,1,0,0,0,932,934,3,66,33,0,933,932,1,0,0,0,934,937,1,0,0,0,935,
  	933,1,0,0,0,935,936,1,0,0,0,936,75,1,0,0,0,937,935,1,0,0,0,938,953,3,
  	44,22,0,939,940,3,0,0,0,940,945,3,70,35,0,941,942,5,2,0,0,942,944,3,30,
  	15,0,943,941,1,0,0,0,944,947,1,0,0,0,945,943,1,0,0,0,945,946,1,0,0,0,
  	946,949,1,0,0,0,947,945,1,0,0,0,948,950,5,2,0,0,949,948,1,0,0,0,949,950,
  	1,0,0,0,950,951,1,0,0,0,951,952,3,2,1,0,952,954,1,0,0,0,953,939,1,0,0,
  	0,953,954,1,0,0,0,954,77,1,0,0,0,955,957,3,58,29,0,956,958,3,20,10,0,
  	957,956,1,0,0,0,957,958,1,0,0,0,958,970,1,0,0,0,959,960,5,56,0,0,960,
  	970,3,78,39,0,961,962,5,22,0,0,962,970,3,78,39,0,963,964,5,65,0,0,964,
  	970,3,78,39,0,965,966,5,64,0,0,966,970,3,78,39,0,967,968,5,57,0,0,968,
  	970,3,78,39,0,969,955,1,0,0,0,969,959,1,0,0,0,969,961,1,0,0,0,969,963,
  	1,0,0,0,969,965,1,0,0,0,969,967,1,0,0,0,970,79,1,0,0,0,971,986,5,36,0,
  	0,972,973,3,0,0,0,973,978,3,30,15,0,974,975,5,2,0,0,975,977,3,30,15,0,
  	976,974,1,0,0,0,977,980,1,0,0,0,978,976,1,0,0,0,978,979,1,0,0,0,979,982,
  	1,0,0,0,980,978,1,0,0,0,981,983,5,2,0,0,982,981,1,0,0,0,982,983,1,0,0,
  	0,983,984,1,0,0,0,984,985,3,2,1,0,985,987,1,0,0,0,986,972,1,0,0,0,986,
  	987,1,0,0,0,987,988,1,0,0,0,988,989,3,54,27,0,989,81,1,0,0,0,990,1006,
  	3,80,40,0,991,992,3,80,40,0,992,993,5,4,0,0,993,994,3,30,15,0,994,1006,
  	1,0,0,0,995,996,5,10,0,0,996,997,3,54,27,0,997,998,5,4,0,0,998,999,3,
  	30,15,0,999,1006,1,0,0,0,1000,1001,5,58,0,0,1001,1002,3,54,27,0,1002,
  	1003,5,4,0,0,1003,1004,3,30,15,0,1004,1006,1,0,0,0,1005,990,1,0,0,0,1005,
  	991,1,0,0,0,1005,995,1,0,0,0,1005,1000,1,0,0,0,1006,83,1,0,0,0,1007,1008,
  	3,48,24,0,1008,1009,7,2,0,0,1009,1010,3,30,15,0,1010,1021,1,0,0,0,1011,
  	1012,3,48,24,0,1012,1013,5,59,0,0,1013,1021,1,0,0,0,1014,1015,3,48,24,
  	0,1015,1016,5,60,0,0,1016,1021,1,0,0,0,1017,1018,5,61,0,0,1018,1019,5,
  	4,0,0,1019,1021,3,30,15,0,1020,1007,1,0,0,0,1020,1011,1,0,0,0,1020,1014,
  	1,0,0,0,1020,1017,1,0,0,0,1021,85,1,0,0,0,121,100,104,106,117,127,132,
  	139,146,155,164,182,191,200,211,222,233,244,255,268,272,280,289,298,301,
  	305,310,315,321,323,328,335,345,352,360,379,393,396,406,413,418,427,437,
  	441,443,450,456,461,468,476,486,490,494,499,524,534,543,547,551,559,570,
  	574,583,587,590,595,602,609,617,623,628,635,640,658,662,664,673,710,715,
  	721,725,729,736,749,754,759,766,773,780,787,795,798,804,812,819,827,843,
  	847,849,873,876,884,888,891,897,900,910,914,918,923,929,935,945,949,953,
  	957,969,978,982,986,1005,1020
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  wgslParserStaticData = staticData.release();
}

}

WGSLParser::WGSLParser(TokenStream *input) : WGSLParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

WGSLParser::WGSLParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  WGSLParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *wgslParserStaticData->atn, wgslParserStaticData->decisionToDFA, wgslParserStaticData->sharedContextCache, options);
}

WGSLParser::~WGSLParser() {
  delete _interpreter;
}

const atn::ATN& WGSLParser::getATN() const {
  return *wgslParserStaticData->atn;
}

std::string WGSLParser::getGrammarFileName() const {
  return "WGSL.txt";
}

const std::vector<std::string>& WGSLParser::getRuleNames() const {
  return wgslParserStaticData->ruleNames;
}

const dfa::Vocabulary& WGSLParser::getVocabulary() const {
  return wgslParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView WGSLParser::getSerializedATN() const {
  return wgslParserStaticData->serializedATN;
}


//----------------- Template_args_startContext ------------------------------------------------------------------

WGSLParser::Template_args_startContext::Template_args_startContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WGSLParser::Template_args_startContext::Left_angle() {
  return getToken(WGSLParser::Left_angle, 0);
}


size_t WGSLParser::Template_args_startContext::getRuleIndex() const {
  return WGSLParser::RuleTemplate_args_start;
}

void WGSLParser::Template_args_startContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemplate_args_start(this);
}

void WGSLParser::Template_args_startContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemplate_args_start(this);
}

WGSLParser::Template_args_startContext* WGSLParser::template_args_start() {
  Template_args_startContext *_localctx = _tracker.createInstance<Template_args_startContext>(_ctx, getState());
  enterRule(_localctx, 0, WGSLParser::RuleTemplate_args_start);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(86);
    match(WGSLParser::Left_angle);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Template_args_endContext ------------------------------------------------------------------

WGSLParser::Template_args_endContext::Template_args_endContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WGSLParser::Template_args_endContext::Right_angle() {
  return getToken(WGSLParser::Right_angle, 0);
}


size_t WGSLParser::Template_args_endContext::getRuleIndex() const {
  return WGSLParser::RuleTemplate_args_end;
}

void WGSLParser::Template_args_endContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemplate_args_end(this);
}

void WGSLParser::Template_args_endContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemplate_args_end(this);
}

WGSLParser::Template_args_endContext* WGSLParser::template_args_end() {
  Template_args_endContext *_localctx = _tracker.createInstance<Template_args_endContext>(_ctx, getState());
  enterRule(_localctx, 2, WGSLParser::RuleTemplate_args_end);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(88);
    match(WGSLParser::Right_angle);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Additive_operatorContext ------------------------------------------------------------------

WGSLParser::Additive_operatorContext::Additive_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WGSLParser::Additive_operatorContext::Minus() {
  return getToken(WGSLParser::Minus, 0);
}

tree::TerminalNode* WGSLParser::Additive_operatorContext::Positive() {
  return getToken(WGSLParser::Positive, 0);
}


size_t WGSLParser::Additive_operatorContext::getRuleIndex() const {
  return WGSLParser::RuleAdditive_operator;
}

void WGSLParser::Additive_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAdditive_operator(this);
}

void WGSLParser::Additive_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAdditive_operator(this);
}

WGSLParser::Additive_operatorContext* WGSLParser::additive_operator() {
  Additive_operatorContext *_localctx = _tracker.createInstance<Additive_operatorContext>(_ctx, getState());
  enterRule(_localctx, 4, WGSLParser::RuleAdditive_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(90);
    _la = _input->LA(1);
    if (!(_la == WGSLParser::Positive

    || _la == WGSLParser::Minus)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Multiplicative_operatorContext ------------------------------------------------------------------

WGSLParser::Multiplicative_operatorContext::Multiplicative_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WGSLParser::Multiplicative_operatorContext::Star() {
  return getToken(WGSLParser::Star, 0);
}

tree::TerminalNode* WGSLParser::Multiplicative_operatorContext::Dash() {
  return getToken(WGSLParser::Dash, 0);
}

tree::TerminalNode* WGSLParser::Multiplicative_operatorContext::MOD() {
  return getToken(WGSLParser::MOD, 0);
}


size_t WGSLParser::Multiplicative_operatorContext::getRuleIndex() const {
  return WGSLParser::RuleMultiplicative_operator;
}

void WGSLParser::Multiplicative_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultiplicative_operator(this);
}

void WGSLParser::Multiplicative_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultiplicative_operator(this);
}

WGSLParser::Multiplicative_operatorContext* WGSLParser::multiplicative_operator() {
  Multiplicative_operatorContext *_localctx = _tracker.createInstance<Multiplicative_operatorContext>(_ctx, getState());
  enterRule(_localctx, 6, WGSLParser::RuleMultiplicative_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(92);
    _la = _input->LA(1);
    if (!(((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Argument_expression_listContext ------------------------------------------------------------------

WGSLParser::Argument_expression_listContext::Argument_expression_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<WGSLParser::ExpressionContext *> WGSLParser::Argument_expression_listContext::expression() {
  return getRuleContexts<WGSLParser::ExpressionContext>();
}

WGSLParser::ExpressionContext* WGSLParser::Argument_expression_listContext::expression(size_t i) {
  return getRuleContext<WGSLParser::ExpressionContext>(i);
}


size_t WGSLParser::Argument_expression_listContext::getRuleIndex() const {
  return WGSLParser::RuleArgument_expression_list;
}

void WGSLParser::Argument_expression_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArgument_expression_list(this);
}

void WGSLParser::Argument_expression_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArgument_expression_list(this);
}

WGSLParser::Argument_expression_listContext* WGSLParser::argument_expression_list() {
  Argument_expression_listContext *_localctx = _tracker.createInstance<Argument_expression_listContext>(_ctx, getState());
  enterRule(_localctx, 8, WGSLParser::RuleArgument_expression_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(94);
    match(WGSLParser::T__0);
    setState(106);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 216172782117978114) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 15811) != 0)) {
      setState(95);
      expression();
      setState(100);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(96);
          match(WGSLParser::T__1);
          setState(97);
          expression(); 
        }
        setState(102);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx);
      }
      setState(104);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__1) {
        setState(103);
        match(WGSLParser::T__1);
      }
    }
    setState(108);
    match(WGSLParser::T__2);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Assignment_statementContext ------------------------------------------------------------------

WGSLParser::Assignment_statementContext::Assignment_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WGSLParser::Assignment_statementContext::Compound_assignment_operator() {
  return getToken(WGSLParser::Compound_assignment_operator, 0);
}


size_t WGSLParser::Assignment_statementContext::getRuleIndex() const {
  return WGSLParser::RuleAssignment_statement;
}

void WGSLParser::Assignment_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment_statement(this);
}

void WGSLParser::Assignment_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment_statement(this);
}

WGSLParser::Assignment_statementContext* WGSLParser::assignment_statement() {
  Assignment_statementContext *_localctx = _tracker.createInstance<Assignment_statementContext>(_ctx, getState());
  enterRule(_localctx, 10, WGSLParser::RuleAssignment_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(110);
    _la = _input->LA(1);
    if (!(_la == WGSLParser::T__3 || _la == WGSLParser::Compound_assignment_operator)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Shift_expression_post_unary_expressionContext ------------------------------------------------------------------

WGSLParser::Shift_expression_post_unary_expressionContext::Shift_expression_post_unary_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<WGSLParser::Multiplicative_operatorContext *> WGSLParser::Shift_expression_post_unary_expressionContext::multiplicative_operator() {
  return getRuleContexts<WGSLParser::Multiplicative_operatorContext>();
}

WGSLParser::Multiplicative_operatorContext* WGSLParser::Shift_expression_post_unary_expressionContext::multiplicative_operator(size_t i) {
  return getRuleContext<WGSLParser::Multiplicative_operatorContext>(i);
}

std::vector<WGSLParser::Unary_expressionContext *> WGSLParser::Shift_expression_post_unary_expressionContext::unary_expression() {
  return getRuleContexts<WGSLParser::Unary_expressionContext>();
}

WGSLParser::Unary_expressionContext* WGSLParser::Shift_expression_post_unary_expressionContext::unary_expression(size_t i) {
  return getRuleContext<WGSLParser::Unary_expressionContext>(i);
}

std::vector<WGSLParser::Additive_operatorContext *> WGSLParser::Shift_expression_post_unary_expressionContext::additive_operator() {
  return getRuleContexts<WGSLParser::Additive_operatorContext>();
}

WGSLParser::Additive_operatorContext* WGSLParser::Shift_expression_post_unary_expressionContext::additive_operator(size_t i) {
  return getRuleContext<WGSLParser::Additive_operatorContext>(i);
}

tree::TerminalNode* WGSLParser::Shift_expression_post_unary_expressionContext::Shift_left() {
  return getToken(WGSLParser::Shift_left, 0);
}

tree::TerminalNode* WGSLParser::Shift_expression_post_unary_expressionContext::Shift_right() {
  return getToken(WGSLParser::Shift_right, 0);
}


size_t WGSLParser::Shift_expression_post_unary_expressionContext::getRuleIndex() const {
  return WGSLParser::RuleShift_expression_post_unary_expression;
}

void WGSLParser::Shift_expression_post_unary_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShift_expression_post_unary_expression(this);
}

void WGSLParser::Shift_expression_post_unary_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShift_expression_post_unary_expression(this);
}

WGSLParser::Shift_expression_post_unary_expressionContext* WGSLParser::shift_expression_post_unary_expression() {
  Shift_expression_post_unary_expressionContext *_localctx = _tracker.createInstance<Shift_expression_post_unary_expressionContext>(_ctx, getState());
  enterRule(_localctx, 12, WGSLParser::RuleShift_expression_post_unary_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(139);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case WGSLParser::T__1:
      case WGSLParser::T__2:
      case WGSLParser::T__4:
      case WGSLParser::T__27:
      case WGSLParser::T__28:
      case WGSLParser::T__30:
      case WGSLParser::T__31:
      case WGSLParser::T__33:
      case WGSLParser::T__36:
      case WGSLParser::T__43:
      case WGSLParser::T__44:
      case WGSLParser::Positive:
      case WGSLParser::Minus:
      case WGSLParser::Star:
      case WGSLParser::Dash:
      case WGSLParser::MOD:
      case WGSLParser::Left_angle:
      case WGSLParser::Right_angle:
      case WGSLParser::Greater_than_equal:
      case WGSLParser::Less_than_equal: {
        enterOuterAlt(_localctx, 1);
        setState(117);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (((((_la - 65) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 65)) & 7) != 0)) {
          setState(112);
          multiplicative_operator();
          setState(113);
          unary_expression();
          setState(119);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(132);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == WGSLParser::Positive

        || _la == WGSLParser::Minus) {
          setState(120);
          additive_operator();
          setState(121);
          unary_expression();
          setState(127);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (((((_la - 65) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 65)) & 7) != 0)) {
            setState(122);
            multiplicative_operator();
            setState(123);
            unary_expression();
            setState(129);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(134);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case WGSLParser::Shift_left: {
        enterOuterAlt(_localctx, 2);
        setState(135);
        match(WGSLParser::Shift_left);
        setState(136);
        unary_expression();
        break;
      }

      case WGSLParser::Shift_right: {
        enterOuterAlt(_localctx, 3);
        setState(137);
        match(WGSLParser::Shift_right);
        setState(138);
        unary_expression();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AttributeContext ------------------------------------------------------------------

WGSLParser::AttributeContext::AttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<WGSLParser::ExpressionContext *> WGSLParser::AttributeContext::expression() {
  return getRuleContexts<WGSLParser::ExpressionContext>();
}

WGSLParser::ExpressionContext* WGSLParser::AttributeContext::expression(size_t i) {
  return getRuleContext<WGSLParser::ExpressionContext>(i);
}

WGSLParser::Diagnostic_controlContext* WGSLParser::AttributeContext::diagnostic_control() {
  return getRuleContext<WGSLParser::Diagnostic_controlContext>(0);
}


size_t WGSLParser::AttributeContext::getRuleIndex() const {
  return WGSLParser::RuleAttribute;
}

void WGSLParser::AttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttribute(this);
}

void WGSLParser::AttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttribute(this);
}

WGSLParser::AttributeContext* WGSLParser::attribute() {
  AttributeContext *_localctx = _tracker.createInstance<AttributeContext>(_ctx, getState());
  enterRule(_localctx, 14, WGSLParser::RuleAttribute);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(272);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(141);
      match(WGSLParser::T__4);
      setState(142);
      match(WGSLParser::T__5);
      setState(143);
      match(WGSLParser::T__0);
      setState(144);
      expression();
      setState(146);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__1) {
        setState(145);
        match(WGSLParser::T__1);
      }
      setState(148);
      match(WGSLParser::T__2);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(150);
      match(WGSLParser::T__4);
      setState(151);
      match(WGSLParser::T__6);
      setState(152);
      match(WGSLParser::T__0);
      setState(153);
      expression();
      setState(155);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__1) {
        setState(154);
        match(WGSLParser::T__1);
      }
      setState(157);
      match(WGSLParser::T__2);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(159);
      match(WGSLParser::T__4);
      setState(160);
      match(WGSLParser::T__7);
      setState(161);
      match(WGSLParser::T__0);
      setState(162);
      expression();
      setState(164);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__1) {
        setState(163);
        match(WGSLParser::T__1);
      }
      setState(166);
      match(WGSLParser::T__2);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(168);
      match(WGSLParser::T__4);
      setState(169);
      match(WGSLParser::T__8);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(170);
      match(WGSLParser::T__4);
      setState(171);
      match(WGSLParser::T__9);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(172);
      match(WGSLParser::T__4);
      setState(173);
      match(WGSLParser::T__10);
      setState(174);
      diagnostic_control();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(175);
      match(WGSLParser::T__4);
      setState(176);
      match(WGSLParser::T__11);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(177);
      match(WGSLParser::T__4);
      setState(178);
      match(WGSLParser::T__12);
      setState(179);
      match(WGSLParser::T__0);
      setState(180);
      expression();
      setState(182);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__1) {
        setState(181);
        match(WGSLParser::T__1);
      }
      setState(184);
      match(WGSLParser::T__2);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(186);
      match(WGSLParser::T__4);
      setState(187);
      match(WGSLParser::T__13);
      setState(188);
      match(WGSLParser::T__0);
      setState(189);
      expression();
      setState(191);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__1) {
        setState(190);
        match(WGSLParser::T__1);
      }
      setState(193);
      match(WGSLParser::T__2);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(195);
      match(WGSLParser::T__4);
      setState(196);
      match(WGSLParser::T__14);
      setState(197);
      match(WGSLParser::T__0);
      setState(198);
      expression();
      setState(200);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__1) {
        setState(199);
        match(WGSLParser::T__1);
      }
      setState(202);
      match(WGSLParser::T__2);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(204);
      match(WGSLParser::T__4);
      setState(205);
      match(WGSLParser::T__14);
      setState(206);
      match(WGSLParser::T__0);
      setState(207);
      expression();
      setState(208);
      match(WGSLParser::T__1);
      setState(209);
      expression();
      setState(211);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__1) {
        setState(210);
        match(WGSLParser::T__1);
      }
      setState(213);
      match(WGSLParser::T__2);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(215);
      match(WGSLParser::T__4);
      setState(216);
      match(WGSLParser::T__15);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(217);
      match(WGSLParser::T__4);
      setState(218);
      match(WGSLParser::T__16);
      setState(219);
      match(WGSLParser::T__0);
      setState(220);
      expression();
      setState(222);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__1) {
        setState(221);
        match(WGSLParser::T__1);
      }
      setState(224);
      match(WGSLParser::T__2);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(226);
      match(WGSLParser::T__4);
      setState(227);
      match(WGSLParser::T__17);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(228);
      match(WGSLParser::T__4);
      setState(229);
      match(WGSLParser::T__18);
      setState(230);
      match(WGSLParser::T__0);
      setState(231);
      expression();
      setState(233);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__1) {
        setState(232);
        match(WGSLParser::T__1);
      }
      setState(235);
      match(WGSLParser::T__2);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(237);
      match(WGSLParser::T__4);
      setState(238);
      match(WGSLParser::T__19);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(239);
      match(WGSLParser::T__4);
      setState(240);
      match(WGSLParser::T__20);
      setState(241);
      match(WGSLParser::T__0);
      setState(242);
      expression();
      setState(244);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__1) {
        setState(243);
        match(WGSLParser::T__1);
      }
      setState(246);
      match(WGSLParser::T__2);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(248);
      match(WGSLParser::T__4);
      setState(249);
      match(WGSLParser::T__20);
      setState(250);
      match(WGSLParser::T__0);
      setState(251);
      expression();
      setState(252);
      match(WGSLParser::T__1);
      setState(253);
      expression();
      setState(255);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__1) {
        setState(254);
        match(WGSLParser::T__1);
      }
      setState(257);
      match(WGSLParser::T__2);
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(259);
      match(WGSLParser::T__4);
      setState(260);
      match(WGSLParser::T__20);
      setState(261);
      match(WGSLParser::T__0);
      setState(262);
      expression();
      setState(263);
      match(WGSLParser::T__1);
      setState(264);
      expression();
      setState(265);
      match(WGSLParser::T__1);
      setState(266);
      expression();
      setState(268);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__1) {
        setState(267);
        match(WGSLParser::T__1);
      }
      setState(270);
      match(WGSLParser::T__2);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Bitwise_expression_post_unary_expressionContext ------------------------------------------------------------------

WGSLParser::Bitwise_expression_post_unary_expressionContext::Bitwise_expression_post_unary_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<WGSLParser::Unary_expressionContext *> WGSLParser::Bitwise_expression_post_unary_expressionContext::unary_expression() {
  return getRuleContexts<WGSLParser::Unary_expressionContext>();
}

WGSLParser::Unary_expressionContext* WGSLParser::Bitwise_expression_post_unary_expressionContext::unary_expression(size_t i) {
  return getRuleContext<WGSLParser::Unary_expressionContext>(i);
}


size_t WGSLParser::Bitwise_expression_post_unary_expressionContext::getRuleIndex() const {
  return WGSLParser::RuleBitwise_expression_post_unary_expression;
}

void WGSLParser::Bitwise_expression_post_unary_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitwise_expression_post_unary_expression(this);
}

void WGSLParser::Bitwise_expression_post_unary_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitwise_expression_post_unary_expression(this);
}

WGSLParser::Bitwise_expression_post_unary_expressionContext* WGSLParser::bitwise_expression_post_unary_expression() {
  Bitwise_expression_post_unary_expressionContext *_localctx = _tracker.createInstance<Bitwise_expression_post_unary_expressionContext>(_ctx, getState());
  enterRule(_localctx, 16, WGSLParser::RuleBitwise_expression_post_unary_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(301);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case WGSLParser::T__21: {
        enterOuterAlt(_localctx, 1);
        setState(274);
        match(WGSLParser::T__21);
        setState(275);
        unary_expression();
        setState(280);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == WGSLParser::T__21) {
          setState(276);
          match(WGSLParser::T__21);
          setState(277);
          unary_expression();
          setState(282);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case WGSLParser::T__22: {
        enterOuterAlt(_localctx, 2);
        setState(283);
        match(WGSLParser::T__22);
        setState(284);
        unary_expression();
        setState(289);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == WGSLParser::T__22) {
          setState(285);
          match(WGSLParser::T__22);
          setState(286);
          unary_expression();
          setState(291);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case WGSLParser::T__23: {
        enterOuterAlt(_localctx, 3);
        setState(292);
        match(WGSLParser::T__23);
        setState(293);
        unary_expression();
        setState(298);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == WGSLParser::T__23) {
          setState(294);
          match(WGSLParser::T__23);
          setState(295);
          unary_expression();
          setState(300);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Case_selectorContext ------------------------------------------------------------------

WGSLParser::Case_selectorContext::Case_selectorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WGSLParser::ExpressionContext* WGSLParser::Case_selectorContext::expression() {
  return getRuleContext<WGSLParser::ExpressionContext>(0);
}


size_t WGSLParser::Case_selectorContext::getRuleIndex() const {
  return WGSLParser::RuleCase_selector;
}

void WGSLParser::Case_selectorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCase_selector(this);
}

void WGSLParser::Case_selectorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCase_selector(this);
}

WGSLParser::Case_selectorContext* WGSLParser::case_selector() {
  Case_selectorContext *_localctx = _tracker.createInstance<Case_selectorContext>(_ctx, getState());
  enterRule(_localctx, 18, WGSLParser::RuleCase_selector);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(305);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case WGSLParser::T__0:
      case WGSLParser::T__21:
      case WGSLParser::T__55:
      case WGSLParser::T__56:
      case WGSLParser::Minus:
      case WGSLParser::Star:
      case WGSLParser::Sigma_term:
      case WGSLParser::Ident_pattern_token:
      case WGSLParser::Bool_literal:
      case WGSLParser::Decimal_float_literal:
      case WGSLParser::Decimal_int_literal:
      case WGSLParser::Hex_float_literal:
      case WGSLParser::Hex_int_literal: {
        enterOuterAlt(_localctx, 1);
        setState(303);
        expression();
        break;
      }

      case WGSLParser::T__24: {
        enterOuterAlt(_localctx, 2);
        setState(304);
        match(WGSLParser::T__24);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Component_or_swizzle_specifierContext ------------------------------------------------------------------

WGSLParser::Component_or_swizzle_specifierContext::Component_or_swizzle_specifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WGSLParser::Member_identContext* WGSLParser::Component_or_swizzle_specifierContext::member_ident() {
  return getRuleContext<WGSLParser::Member_identContext>(0);
}

WGSLParser::Component_or_swizzle_specifierContext* WGSLParser::Component_or_swizzle_specifierContext::component_or_swizzle_specifier() {
  return getRuleContext<WGSLParser::Component_or_swizzle_specifierContext>(0);
}

tree::TerminalNode* WGSLParser::Component_or_swizzle_specifierContext::Swizzle_name() {
  return getToken(WGSLParser::Swizzle_name, 0);
}

WGSLParser::ExpressionContext* WGSLParser::Component_or_swizzle_specifierContext::expression() {
  return getRuleContext<WGSLParser::ExpressionContext>(0);
}


size_t WGSLParser::Component_or_swizzle_specifierContext::getRuleIndex() const {
  return WGSLParser::RuleComponent_or_swizzle_specifier;
}

void WGSLParser::Component_or_swizzle_specifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponent_or_swizzle_specifier(this);
}

void WGSLParser::Component_or_swizzle_specifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponent_or_swizzle_specifier(this);
}

WGSLParser::Component_or_swizzle_specifierContext* WGSLParser::component_or_swizzle_specifier() {
  Component_or_swizzle_specifierContext *_localctx = _tracker.createInstance<Component_or_swizzle_specifierContext>(_ctx, getState());
  enterRule(_localctx, 20, WGSLParser::RuleComponent_or_swizzle_specifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(323);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(307);
      match(WGSLParser::T__25);
      setState(308);
      member_ident();
      setState(310);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__25

      || _la == WGSLParser::T__26) {
        setState(309);
        component_or_swizzle_specifier();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(312);
      match(WGSLParser::T__25);
      setState(313);
      match(WGSLParser::Swizzle_name);
      setState(315);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__25

      || _la == WGSLParser::T__26) {
        setState(314);
        component_or_swizzle_specifier();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(317);
      match(WGSLParser::T__26);
      setState(318);
      expression();
      setState(319);
      match(WGSLParser::T__27);
      setState(321);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__25

      || _la == WGSLParser::T__26) {
        setState(320);
        component_or_swizzle_specifier();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Compound_statementContext ------------------------------------------------------------------

WGSLParser::Compound_statementContext::Compound_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<WGSLParser::AttributeContext *> WGSLParser::Compound_statementContext::attribute() {
  return getRuleContexts<WGSLParser::AttributeContext>();
}

WGSLParser::AttributeContext* WGSLParser::Compound_statementContext::attribute(size_t i) {
  return getRuleContext<WGSLParser::AttributeContext>(i);
}

std::vector<WGSLParser::StatementContext *> WGSLParser::Compound_statementContext::statement() {
  return getRuleContexts<WGSLParser::StatementContext>();
}

WGSLParser::StatementContext* WGSLParser::Compound_statementContext::statement(size_t i) {
  return getRuleContext<WGSLParser::StatementContext>(i);
}


size_t WGSLParser::Compound_statementContext::getRuleIndex() const {
  return WGSLParser::RuleCompound_statement;
}

void WGSLParser::Compound_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompound_statement(this);
}

void WGSLParser::Compound_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompound_statement(this);
}

WGSLParser::Compound_statementContext* WGSLParser::compound_statement() {
  Compound_statementContext *_localctx = _tracker.createInstance<Compound_statementContext>(_ctx, getState());
  enterRule(_localctx, 22, WGSLParser::RuleCompound_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(328);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == WGSLParser::T__4) {
      setState(325);
      attribute();
      setState(330);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(331);
    match(WGSLParser::T__28);
    setState(335);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2628625195211949090) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & 393313) != 0)) {
      setState(332);
      statement();
      setState(337);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(338);
    match(WGSLParser::T__29);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Core_lhs_expressionContext ------------------------------------------------------------------

WGSLParser::Core_lhs_expressionContext::Core_lhs_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WGSLParser::IdentContext* WGSLParser::Core_lhs_expressionContext::ident() {
  return getRuleContext<WGSLParser::IdentContext>(0);
}

WGSLParser::Lhs_expressionContext* WGSLParser::Core_lhs_expressionContext::lhs_expression() {
  return getRuleContext<WGSLParser::Lhs_expressionContext>(0);
}


size_t WGSLParser::Core_lhs_expressionContext::getRuleIndex() const {
  return WGSLParser::RuleCore_lhs_expression;
}

void WGSLParser::Core_lhs_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCore_lhs_expression(this);
}

void WGSLParser::Core_lhs_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCore_lhs_expression(this);
}

WGSLParser::Core_lhs_expressionContext* WGSLParser::core_lhs_expression() {
  Core_lhs_expressionContext *_localctx = _tracker.createInstance<Core_lhs_expressionContext>(_ctx, getState());
  enterRule(_localctx, 24, WGSLParser::RuleCore_lhs_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(345);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case WGSLParser::Sigma_term:
      case WGSLParser::Ident_pattern_token: {
        enterOuterAlt(_localctx, 1);
        setState(340);
        ident();
        break;
      }

      case WGSLParser::T__0: {
        enterOuterAlt(_localctx, 2);
        setState(341);
        match(WGSLParser::T__0);
        setState(342);
        lhs_expression();
        setState(343);
        match(WGSLParser::T__2);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Diagnostic_controlContext ------------------------------------------------------------------

WGSLParser::Diagnostic_controlContext::Diagnostic_controlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WGSLParser::Diagnostic_controlContext::Severity_control_name() {
  return getToken(WGSLParser::Severity_control_name, 0);
}

WGSLParser::Diagnostic_rule_nameContext* WGSLParser::Diagnostic_controlContext::diagnostic_rule_name() {
  return getRuleContext<WGSLParser::Diagnostic_rule_nameContext>(0);
}


size_t WGSLParser::Diagnostic_controlContext::getRuleIndex() const {
  return WGSLParser::RuleDiagnostic_control;
}

void WGSLParser::Diagnostic_controlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDiagnostic_control(this);
}

void WGSLParser::Diagnostic_controlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDiagnostic_control(this);
}

WGSLParser::Diagnostic_controlContext* WGSLParser::diagnostic_control() {
  Diagnostic_controlContext *_localctx = _tracker.createInstance<Diagnostic_controlContext>(_ctx, getState());
  enterRule(_localctx, 26, WGSLParser::RuleDiagnostic_control);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(347);
    match(WGSLParser::T__0);
    setState(348);
    match(WGSLParser::Severity_control_name);
    setState(349);
    match(WGSLParser::T__1);
    setState(350);
    diagnostic_rule_name();
    setState(352);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == WGSLParser::T__1) {
      setState(351);
      match(WGSLParser::T__1);
    }
    setState(354);
    match(WGSLParser::T__2);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Diagnostic_rule_nameContext ------------------------------------------------------------------

WGSLParser::Diagnostic_rule_nameContext::Diagnostic_rule_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> WGSLParser::Diagnostic_rule_nameContext::Ident_pattern_token() {
  return getTokens(WGSLParser::Ident_pattern_token);
}

tree::TerminalNode* WGSLParser::Diagnostic_rule_nameContext::Ident_pattern_token(size_t i) {
  return getToken(WGSLParser::Ident_pattern_token, i);
}


size_t WGSLParser::Diagnostic_rule_nameContext::getRuleIndex() const {
  return WGSLParser::RuleDiagnostic_rule_name;
}

void WGSLParser::Diagnostic_rule_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDiagnostic_rule_name(this);
}

void WGSLParser::Diagnostic_rule_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDiagnostic_rule_name(this);
}

WGSLParser::Diagnostic_rule_nameContext* WGSLParser::diagnostic_rule_name() {
  Diagnostic_rule_nameContext *_localctx = _tracker.createInstance<Diagnostic_rule_nameContext>(_ctx, getState());
  enterRule(_localctx, 28, WGSLParser::RuleDiagnostic_rule_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(360);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(356);
      match(WGSLParser::Ident_pattern_token);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(357);
      match(WGSLParser::Ident_pattern_token);
      setState(358);
      match(WGSLParser::T__25);
      setState(359);
      match(WGSLParser::Ident_pattern_token);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

WGSLParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<WGSLParser::Unary_expressionContext *> WGSLParser::ExpressionContext::unary_expression() {
  return getRuleContexts<WGSLParser::Unary_expressionContext>();
}

WGSLParser::Unary_expressionContext* WGSLParser::ExpressionContext::unary_expression(size_t i) {
  return getRuleContext<WGSLParser::Unary_expressionContext>(i);
}

WGSLParser::Bitwise_expression_post_unary_expressionContext* WGSLParser::ExpressionContext::bitwise_expression_post_unary_expression() {
  return getRuleContext<WGSLParser::Bitwise_expression_post_unary_expressionContext>(0);
}

std::vector<WGSLParser::Relational_expression_post_unary_expressionContext *> WGSLParser::ExpressionContext::relational_expression_post_unary_expression() {
  return getRuleContexts<WGSLParser::Relational_expression_post_unary_expressionContext>();
}

WGSLParser::Relational_expression_post_unary_expressionContext* WGSLParser::ExpressionContext::relational_expression_post_unary_expression(size_t i) {
  return getRuleContext<WGSLParser::Relational_expression_post_unary_expressionContext>(i);
}


size_t WGSLParser::ExpressionContext::getRuleIndex() const {
  return WGSLParser::RuleExpression;
}

void WGSLParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void WGSLParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}

WGSLParser::ExpressionContext* WGSLParser::expression() {
  ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, getState());
  enterRule(_localctx, 30, WGSLParser::RuleExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(396);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(362);
      unary_expression();
      setState(363);
      bitwise_expression_post_unary_expression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(365);
      unary_expression();
      setState(366);
      relational_expression_post_unary_expression();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(368);
      unary_expression();
      setState(369);
      relational_expression_post_unary_expression();
      setState(370);
      match(WGSLParser::T__30);
      setState(371);
      unary_expression();
      setState(372);
      relational_expression_post_unary_expression();
      setState(379);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WGSLParser::T__30) {
        setState(373);
        match(WGSLParser::T__30);
        setState(374);
        unary_expression();
        setState(375);
        relational_expression_post_unary_expression();
        setState(381);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(382);
      unary_expression();
      setState(383);
      relational_expression_post_unary_expression();
      setState(384);
      match(WGSLParser::T__31);
      setState(385);
      unary_expression();
      setState(386);
      relational_expression_post_unary_expression();
      setState(393);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WGSLParser::T__31) {
        setState(387);
        match(WGSLParser::T__31);
        setState(388);
        unary_expression();
        setState(389);
        relational_expression_post_unary_expression();
        setState(395);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Float_literalContext ------------------------------------------------------------------

WGSLParser::Float_literalContext::Float_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WGSLParser::Float_literalContext::Decimal_float_literal() {
  return getToken(WGSLParser::Decimal_float_literal, 0);
}

tree::TerminalNode* WGSLParser::Float_literalContext::Hex_float_literal() {
  return getToken(WGSLParser::Hex_float_literal, 0);
}


size_t WGSLParser::Float_literalContext::getRuleIndex() const {
  return WGSLParser::RuleFloat_literal;
}

void WGSLParser::Float_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFloat_literal(this);
}

void WGSLParser::Float_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFloat_literal(this);
}

WGSLParser::Float_literalContext* WGSLParser::float_literal() {
  Float_literalContext *_localctx = _tracker.createInstance<Float_literalContext>(_ctx, getState());
  enterRule(_localctx, 32, WGSLParser::RuleFloat_literal);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(398);
    _la = _input->LA(1);
    if (!(_la == WGSLParser::Decimal_float_literal

    || _la == WGSLParser::Hex_float_literal)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_initContext ------------------------------------------------------------------

WGSLParser::For_initContext::For_initContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WGSLParser::IdentContext* WGSLParser::For_initContext::ident() {
  return getRuleContext<WGSLParser::IdentContext>(0);
}

WGSLParser::Template_elaborated_ident_post_identContext* WGSLParser::For_initContext::template_elaborated_ident_post_ident() {
  return getRuleContext<WGSLParser::Template_elaborated_ident_post_identContext>(0);
}

WGSLParser::Argument_expression_listContext* WGSLParser::For_initContext::argument_expression_list() {
  return getRuleContext<WGSLParser::Argument_expression_listContext>(0);
}

WGSLParser::Variable_or_value_statementContext* WGSLParser::For_initContext::variable_or_value_statement() {
  return getRuleContext<WGSLParser::Variable_or_value_statementContext>(0);
}

WGSLParser::Variable_updating_statementContext* WGSLParser::For_initContext::variable_updating_statement() {
  return getRuleContext<WGSLParser::Variable_updating_statementContext>(0);
}


size_t WGSLParser::For_initContext::getRuleIndex() const {
  return WGSLParser::RuleFor_init;
}

void WGSLParser::For_initContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFor_init(this);
}

void WGSLParser::For_initContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFor_init(this);
}

WGSLParser::For_initContext* WGSLParser::for_init() {
  For_initContext *_localctx = _tracker.createInstance<For_initContext>(_ctx, getState());
  enterRule(_localctx, 34, WGSLParser::RuleFor_init);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(406);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(400);
      ident();
      setState(401);
      template_elaborated_ident_post_ident();
      setState(402);
      argument_expression_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(404);
      variable_or_value_statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(405);
      variable_updating_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- For_updateContext ------------------------------------------------------------------

WGSLParser::For_updateContext::For_updateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WGSLParser::IdentContext* WGSLParser::For_updateContext::ident() {
  return getRuleContext<WGSLParser::IdentContext>(0);
}

WGSLParser::Template_elaborated_ident_post_identContext* WGSLParser::For_updateContext::template_elaborated_ident_post_ident() {
  return getRuleContext<WGSLParser::Template_elaborated_ident_post_identContext>(0);
}

WGSLParser::Argument_expression_listContext* WGSLParser::For_updateContext::argument_expression_list() {
  return getRuleContext<WGSLParser::Argument_expression_listContext>(0);
}

WGSLParser::Variable_updating_statementContext* WGSLParser::For_updateContext::variable_updating_statement() {
  return getRuleContext<WGSLParser::Variable_updating_statementContext>(0);
}


size_t WGSLParser::For_updateContext::getRuleIndex() const {
  return WGSLParser::RuleFor_update;
}

void WGSLParser::For_updateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFor_update(this);
}

void WGSLParser::For_updateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFor_update(this);
}

WGSLParser::For_updateContext* WGSLParser::for_update() {
  For_updateContext *_localctx = _tracker.createInstance<For_updateContext>(_ctx, getState());
  enterRule(_localctx, 36, WGSLParser::RuleFor_update);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(413);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(408);
      ident();
      setState(409);
      template_elaborated_ident_post_ident();
      setState(410);
      argument_expression_list();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(412);
      variable_updating_statement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Global_declContext ------------------------------------------------------------------

WGSLParser::Global_declContext::Global_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<WGSLParser::IdentContext *> WGSLParser::Global_declContext::ident() {
  return getRuleContexts<WGSLParser::IdentContext>();
}

WGSLParser::IdentContext* WGSLParser::Global_declContext::ident(size_t i) {
  return getRuleContext<WGSLParser::IdentContext>(i);
}

std::vector<WGSLParser::AttributeContext *> WGSLParser::Global_declContext::attribute() {
  return getRuleContexts<WGSLParser::AttributeContext>();
}

WGSLParser::AttributeContext* WGSLParser::Global_declContext::attribute(size_t i) {
  return getRuleContext<WGSLParser::AttributeContext>(i);
}

std::vector<WGSLParser::Type_specifierContext *> WGSLParser::Global_declContext::type_specifier() {
  return getRuleContexts<WGSLParser::Type_specifierContext>();
}

WGSLParser::Type_specifierContext* WGSLParser::Global_declContext::type_specifier(size_t i) {
  return getRuleContext<WGSLParser::Type_specifierContext>(i);
}

WGSLParser::Template_elaborated_ident_post_identContext* WGSLParser::Global_declContext::template_elaborated_ident_post_ident() {
  return getRuleContext<WGSLParser::Template_elaborated_ident_post_identContext>(0);
}

std::vector<WGSLParser::StatementContext *> WGSLParser::Global_declContext::statement() {
  return getRuleContexts<WGSLParser::StatementContext>();
}

WGSLParser::StatementContext* WGSLParser::Global_declContext::statement(size_t i) {
  return getRuleContext<WGSLParser::StatementContext>(i);
}

std::vector<WGSLParser::ParamContext *> WGSLParser::Global_declContext::param() {
  return getRuleContexts<WGSLParser::ParamContext>();
}

WGSLParser::ParamContext* WGSLParser::Global_declContext::param(size_t i) {
  return getRuleContext<WGSLParser::ParamContext>(i);
}

WGSLParser::Optionally_typed_identContext* WGSLParser::Global_declContext::optionally_typed_ident() {
  return getRuleContext<WGSLParser::Optionally_typed_identContext>(0);
}

WGSLParser::Template_args_startContext* WGSLParser::Global_declContext::template_args_start() {
  return getRuleContext<WGSLParser::Template_args_startContext>(0);
}

std::vector<WGSLParser::ExpressionContext *> WGSLParser::Global_declContext::expression() {
  return getRuleContexts<WGSLParser::ExpressionContext>();
}

WGSLParser::ExpressionContext* WGSLParser::Global_declContext::expression(size_t i) {
  return getRuleContext<WGSLParser::ExpressionContext>(i);
}

WGSLParser::Template_args_endContext* WGSLParser::Global_declContext::template_args_end() {
  return getRuleContext<WGSLParser::Template_args_endContext>(0);
}

WGSLParser::Global_value_declContext* WGSLParser::Global_declContext::global_value_decl() {
  return getRuleContext<WGSLParser::Global_value_declContext>(0);
}

std::vector<WGSLParser::Member_identContext *> WGSLParser::Global_declContext::member_ident() {
  return getRuleContexts<WGSLParser::Member_identContext>();
}

WGSLParser::Member_identContext* WGSLParser::Global_declContext::member_ident(size_t i) {
  return getRuleContext<WGSLParser::Member_identContext>(i);
}


size_t WGSLParser::Global_declContext::getRuleIndex() const {
  return WGSLParser::RuleGlobal_decl;
}

void WGSLParser::Global_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGlobal_decl(this);
}

void WGSLParser::Global_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGlobal_decl(this);
}

WGSLParser::Global_declContext* WGSLParser::global_decl() {
  Global_declContext *_localctx = _tracker.createInstance<Global_declContext>(_ctx, getState());
  enterRule(_localctx, 38, WGSLParser::RuleGlobal_decl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(551);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(418);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WGSLParser::T__4) {
        setState(415);
        attribute();
        setState(420);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(421);
      match(WGSLParser::T__32);
      setState(422);
      ident();
      setState(423);
      match(WGSLParser::T__0);
      setState(443);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__4 || _la == WGSLParser::Sigma_term

      || _la == WGSLParser::Ident_pattern_token) {
        setState(427);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == WGSLParser::T__4) {
          setState(424);
          attribute();
          setState(429);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(430);
        ident();
        setState(431);
        match(WGSLParser::T__33);
        setState(432);
        type_specifier();
        setState(437);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(433);
            match(WGSLParser::T__1);
            setState(434);
            param(); 
          }
          setState(439);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx);
        }
        setState(441);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WGSLParser::T__1) {
          setState(440);
          match(WGSLParser::T__1);
        }
      }
      setState(445);
      match(WGSLParser::T__2);
      setState(456);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__34) {
        setState(446);
        match(WGSLParser::T__34);
        setState(450);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == WGSLParser::T__4) {
          setState(447);
          attribute();
          setState(452);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(453);
        ident();
        setState(454);
        template_elaborated_ident_post_ident();
      }
      setState(461);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WGSLParser::T__4) {
        setState(458);
        attribute();
        setState(463);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(464);
      match(WGSLParser::T__28);
      setState(468);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2628625195211949090) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 65)) & 393313) != 0)) {
        setState(465);
        statement();
        setState(470);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(471);
      match(WGSLParser::T__29);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(476);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WGSLParser::T__4) {
        setState(473);
        attribute();
        setState(478);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(479);
      match(WGSLParser::T__35);
      setState(494);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::Left_angle) {
        setState(480);
        template_args_start();
        setState(481);
        expression();
        setState(486);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(482);
            match(WGSLParser::T__1);
            setState(483);
            expression(); 
          }
          setState(488);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx);
        }
        setState(490);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WGSLParser::T__1) {
          setState(489);
          match(WGSLParser::T__1);
        }
        setState(492);
        template_args_end();
      }
      setState(496);
      optionally_typed_ident();
      setState(499);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__3) {
        setState(497);
        match(WGSLParser::T__3);
        setState(498);
        expression();
      }
      setState(501);
      match(WGSLParser::T__36);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(503);
      global_value_decl();
      setState(504);
      match(WGSLParser::T__36);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(506);
      match(WGSLParser::T__36);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(507);
      match(WGSLParser::T__37);
      setState(508);
      ident();
      setState(509);
      match(WGSLParser::T__3);
      setState(510);
      ident();
      setState(511);
      template_elaborated_ident_post_ident();
      setState(512);
      match(WGSLParser::T__36);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(514);
      match(WGSLParser::T__38);
      setState(515);
      expression();
      setState(516);
      match(WGSLParser::T__36);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(518);
      match(WGSLParser::T__39);
      setState(519);
      ident();
      setState(520);
      match(WGSLParser::T__28);
      setState(524);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WGSLParser::T__4) {
        setState(521);
        attribute();
        setState(526);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(527);
      member_ident();
      setState(528);
      match(WGSLParser::T__33);
      setState(529);
      type_specifier();
      setState(543);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(530);
          match(WGSLParser::T__1);
          setState(534);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == WGSLParser::T__4) {
            setState(531);
            attribute();
            setState(536);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(537);
          member_ident();
          setState(538);
          match(WGSLParser::T__33);
          setState(539);
          type_specifier(); 
        }
        setState(545);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, _ctx);
      }
      setState(547);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__1) {
        setState(546);
        match(WGSLParser::T__1);
      }
      setState(549);
      match(WGSLParser::T__29);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Global_directiveContext ------------------------------------------------------------------

WGSLParser::Global_directiveContext::Global_directiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WGSLParser::Global_directiveContext::Severity_control_name() {
  return getToken(WGSLParser::Severity_control_name, 0);
}

WGSLParser::Diagnostic_rule_nameContext* WGSLParser::Global_directiveContext::diagnostic_rule_name() {
  return getRuleContext<WGSLParser::Diagnostic_rule_nameContext>(0);
}

std::vector<tree::TerminalNode *> WGSLParser::Global_directiveContext::Ident_pattern_token() {
  return getTokens(WGSLParser::Ident_pattern_token);
}

tree::TerminalNode* WGSLParser::Global_directiveContext::Ident_pattern_token(size_t i) {
  return getToken(WGSLParser::Ident_pattern_token, i);
}


size_t WGSLParser::Global_directiveContext::getRuleIndex() const {
  return WGSLParser::RuleGlobal_directive;
}

void WGSLParser::Global_directiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGlobal_directive(this);
}

void WGSLParser::Global_directiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGlobal_directive(this);
}

WGSLParser::Global_directiveContext* WGSLParser::global_directive() {
  Global_directiveContext *_localctx = _tracker.createInstance<Global_directiveContext>(_ctx, getState());
  enterRule(_localctx, 40, WGSLParser::RuleGlobal_directive);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(590);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case WGSLParser::T__10: {
        enterOuterAlt(_localctx, 1);
        setState(553);
        match(WGSLParser::T__10);
        setState(554);
        match(WGSLParser::T__0);
        setState(555);
        match(WGSLParser::Severity_control_name);
        setState(556);
        match(WGSLParser::T__1);
        setState(557);
        diagnostic_rule_name();
        setState(559);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WGSLParser::T__1) {
          setState(558);
          match(WGSLParser::T__1);
        }
        setState(561);
        match(WGSLParser::T__2);
        setState(562);
        match(WGSLParser::T__36);
        break;
      }

      case WGSLParser::T__40: {
        enterOuterAlt(_localctx, 2);
        setState(564);
        match(WGSLParser::T__40);
        setState(565);
        match(WGSLParser::Ident_pattern_token);
        setState(570);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(566);
            match(WGSLParser::T__1);
            setState(567);
            match(WGSLParser::Ident_pattern_token); 
          }
          setState(572);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx);
        }
        setState(574);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WGSLParser::T__1) {
          setState(573);
          match(WGSLParser::T__1);
        }
        setState(576);
        match(WGSLParser::T__36);
        break;
      }

      case WGSLParser::T__41: {
        enterOuterAlt(_localctx, 3);
        setState(577);
        match(WGSLParser::T__41);
        setState(578);
        match(WGSLParser::Ident_pattern_token);
        setState(583);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(579);
            match(WGSLParser::T__1);
            setState(580);
            match(WGSLParser::Ident_pattern_token); 
          }
          setState(585);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx);
        }
        setState(587);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WGSLParser::T__1) {
          setState(586);
          match(WGSLParser::T__1);
        }
        setState(589);
        match(WGSLParser::T__36);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Global_value_declContext ------------------------------------------------------------------

WGSLParser::Global_value_declContext::Global_value_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WGSLParser::Optionally_typed_identContext* WGSLParser::Global_value_declContext::optionally_typed_ident() {
  return getRuleContext<WGSLParser::Optionally_typed_identContext>(0);
}

std::vector<WGSLParser::AttributeContext *> WGSLParser::Global_value_declContext::attribute() {
  return getRuleContexts<WGSLParser::AttributeContext>();
}

WGSLParser::AttributeContext* WGSLParser::Global_value_declContext::attribute(size_t i) {
  return getRuleContext<WGSLParser::AttributeContext>(i);
}

WGSLParser::ExpressionContext* WGSLParser::Global_value_declContext::expression() {
  return getRuleContext<WGSLParser::ExpressionContext>(0);
}


size_t WGSLParser::Global_value_declContext::getRuleIndex() const {
  return WGSLParser::RuleGlobal_value_decl;
}

void WGSLParser::Global_value_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGlobal_value_decl(this);
}

void WGSLParser::Global_value_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGlobal_value_decl(this);
}

WGSLParser::Global_value_declContext* WGSLParser::global_value_decl() {
  Global_value_declContext *_localctx = _tracker.createInstance<Global_value_declContext>(_ctx, getState());
  enterRule(_localctx, 42, WGSLParser::RuleGlobal_value_decl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(609);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case WGSLParser::T__4:
      case WGSLParser::T__42: {
        enterOuterAlt(_localctx, 1);
        setState(595);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == WGSLParser::T__4) {
          setState(592);
          attribute();
          setState(597);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(598);
        match(WGSLParser::T__42);
        setState(599);
        optionally_typed_ident();
        setState(602);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WGSLParser::T__3) {
          setState(600);
          match(WGSLParser::T__3);
          setState(601);
          expression();
        }
        break;
      }

      case WGSLParser::T__9: {
        enterOuterAlt(_localctx, 2);
        setState(604);
        match(WGSLParser::T__9);
        setState(605);
        optionally_typed_ident();
        setState(606);
        match(WGSLParser::T__3);
        setState(607);
        expression();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentContext ------------------------------------------------------------------

WGSLParser::IdentContext::IdentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WGSLParser::IdentContext::Ident_pattern_token() {
  return getToken(WGSLParser::Ident_pattern_token, 0);
}

tree::TerminalNode* WGSLParser::IdentContext::Sigma_term() {
  return getToken(WGSLParser::Sigma_term, 0);
}


size_t WGSLParser::IdentContext::getRuleIndex() const {
  return WGSLParser::RuleIdent;
}

void WGSLParser::IdentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdent(this);
}

void WGSLParser::IdentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdent(this);
}

WGSLParser::IdentContext* WGSLParser::ident() {
  IdentContext *_localctx = _tracker.createInstance<IdentContext>(_ctx, getState());
  enterRule(_localctx, 44, WGSLParser::RuleIdent);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(611);
    _la = _input->LA(1);
    if (!(_la == WGSLParser::Sigma_term

    || _la == WGSLParser::Ident_pattern_token)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Int_literalContext ------------------------------------------------------------------

WGSLParser::Int_literalContext::Int_literalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WGSLParser::Int_literalContext::Decimal_int_literal() {
  return getToken(WGSLParser::Decimal_int_literal, 0);
}

tree::TerminalNode* WGSLParser::Int_literalContext::Hex_int_literal() {
  return getToken(WGSLParser::Hex_int_literal, 0);
}


size_t WGSLParser::Int_literalContext::getRuleIndex() const {
  return WGSLParser::RuleInt_literal;
}

void WGSLParser::Int_literalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInt_literal(this);
}

void WGSLParser::Int_literalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInt_literal(this);
}

WGSLParser::Int_literalContext* WGSLParser::int_literal() {
  Int_literalContext *_localctx = _tracker.createInstance<Int_literalContext>(_ctx, getState());
  enterRule(_localctx, 46, WGSLParser::RuleInt_literal);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(613);
    _la = _input->LA(1);
    if (!(_la == WGSLParser::Decimal_int_literal

    || _la == WGSLParser::Hex_int_literal)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Lhs_expressionContext ------------------------------------------------------------------

WGSLParser::Lhs_expressionContext::Lhs_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WGSLParser::Core_lhs_expressionContext* WGSLParser::Lhs_expressionContext::core_lhs_expression() {
  return getRuleContext<WGSLParser::Core_lhs_expressionContext>(0);
}

WGSLParser::Component_or_swizzle_specifierContext* WGSLParser::Lhs_expressionContext::component_or_swizzle_specifier() {
  return getRuleContext<WGSLParser::Component_or_swizzle_specifierContext>(0);
}

WGSLParser::Lhs_expressionContext* WGSLParser::Lhs_expressionContext::lhs_expression() {
  return getRuleContext<WGSLParser::Lhs_expressionContext>(0);
}

tree::TerminalNode* WGSLParser::Lhs_expressionContext::Star() {
  return getToken(WGSLParser::Star, 0);
}


size_t WGSLParser::Lhs_expressionContext::getRuleIndex() const {
  return WGSLParser::RuleLhs_expression;
}

void WGSLParser::Lhs_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLhs_expression(this);
}

void WGSLParser::Lhs_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLhs_expression(this);
}

WGSLParser::Lhs_expressionContext* WGSLParser::lhs_expression() {
  Lhs_expressionContext *_localctx = _tracker.createInstance<Lhs_expressionContext>(_ctx, getState());
  enterRule(_localctx, 48, WGSLParser::RuleLhs_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(623);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case WGSLParser::T__0:
      case WGSLParser::Sigma_term:
      case WGSLParser::Ident_pattern_token: {
        enterOuterAlt(_localctx, 1);
        setState(615);
        core_lhs_expression();
        setState(617);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WGSLParser::T__25

        || _la == WGSLParser::T__26) {
          setState(616);
          component_or_swizzle_specifier();
        }
        break;
      }

      case WGSLParser::T__21: {
        enterOuterAlt(_localctx, 2);
        setState(619);
        match(WGSLParser::T__21);
        setState(620);
        lhs_expression();
        break;
      }

      case WGSLParser::Star: {
        enterOuterAlt(_localctx, 3);
        setState(621);
        match(WGSLParser::Star);
        setState(622);
        lhs_expression();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

WGSLParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WGSLParser::LiteralContext::Bool_literal() {
  return getToken(WGSLParser::Bool_literal, 0);
}

WGSLParser::Float_literalContext* WGSLParser::LiteralContext::float_literal() {
  return getRuleContext<WGSLParser::Float_literalContext>(0);
}

WGSLParser::Int_literalContext* WGSLParser::LiteralContext::int_literal() {
  return getRuleContext<WGSLParser::Int_literalContext>(0);
}


size_t WGSLParser::LiteralContext::getRuleIndex() const {
  return WGSLParser::RuleLiteral;
}

void WGSLParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void WGSLParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}

WGSLParser::LiteralContext* WGSLParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 50, WGSLParser::RuleLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(628);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case WGSLParser::Bool_literal: {
        enterOuterAlt(_localctx, 1);
        setState(625);
        match(WGSLParser::Bool_literal);
        break;
      }

      case WGSLParser::Decimal_float_literal:
      case WGSLParser::Hex_float_literal: {
        enterOuterAlt(_localctx, 2);
        setState(626);
        float_literal();
        break;
      }

      case WGSLParser::Decimal_int_literal:
      case WGSLParser::Hex_int_literal: {
        enterOuterAlt(_localctx, 3);
        setState(627);
        int_literal();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Member_identContext ------------------------------------------------------------------

WGSLParser::Member_identContext::Member_identContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WGSLParser::Member_identContext::Ident_pattern_token() {
  return getToken(WGSLParser::Ident_pattern_token, 0);
}


size_t WGSLParser::Member_identContext::getRuleIndex() const {
  return WGSLParser::RuleMember_ident;
}

void WGSLParser::Member_identContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMember_ident(this);
}

void WGSLParser::Member_identContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMember_ident(this);
}

WGSLParser::Member_identContext* WGSLParser::member_ident() {
  Member_identContext *_localctx = _tracker.createInstance<Member_identContext>(_ctx, getState());
  enterRule(_localctx, 52, WGSLParser::RuleMember_ident);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(630);
    match(WGSLParser::Ident_pattern_token);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Optionally_typed_identContext ------------------------------------------------------------------

WGSLParser::Optionally_typed_identContext::Optionally_typed_identContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WGSLParser::IdentContext* WGSLParser::Optionally_typed_identContext::ident() {
  return getRuleContext<WGSLParser::IdentContext>(0);
}

WGSLParser::Type_specifierContext* WGSLParser::Optionally_typed_identContext::type_specifier() {
  return getRuleContext<WGSLParser::Type_specifierContext>(0);
}


size_t WGSLParser::Optionally_typed_identContext::getRuleIndex() const {
  return WGSLParser::RuleOptionally_typed_ident;
}

void WGSLParser::Optionally_typed_identContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionally_typed_ident(this);
}

void WGSLParser::Optionally_typed_identContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionally_typed_ident(this);
}

WGSLParser::Optionally_typed_identContext* WGSLParser::optionally_typed_ident() {
  Optionally_typed_identContext *_localctx = _tracker.createInstance<Optionally_typed_identContext>(_ctx, getState());
  enterRule(_localctx, 54, WGSLParser::RuleOptionally_typed_ident);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(632);
    ident();
    setState(635);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == WGSLParser::T__33) {
      setState(633);
      match(WGSLParser::T__33);
      setState(634);
      type_specifier();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParamContext ------------------------------------------------------------------

WGSLParser::ParamContext::ParamContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WGSLParser::IdentContext* WGSLParser::ParamContext::ident() {
  return getRuleContext<WGSLParser::IdentContext>(0);
}

WGSLParser::Type_specifierContext* WGSLParser::ParamContext::type_specifier() {
  return getRuleContext<WGSLParser::Type_specifierContext>(0);
}

std::vector<WGSLParser::AttributeContext *> WGSLParser::ParamContext::attribute() {
  return getRuleContexts<WGSLParser::AttributeContext>();
}

WGSLParser::AttributeContext* WGSLParser::ParamContext::attribute(size_t i) {
  return getRuleContext<WGSLParser::AttributeContext>(i);
}


size_t WGSLParser::ParamContext::getRuleIndex() const {
  return WGSLParser::RuleParam;
}

void WGSLParser::ParamContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParam(this);
}

void WGSLParser::ParamContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParam(this);
}

WGSLParser::ParamContext* WGSLParser::param() {
  ParamContext *_localctx = _tracker.createInstance<ParamContext>(_ctx, getState());
  enterRule(_localctx, 56, WGSLParser::RuleParam);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(640);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == WGSLParser::T__4) {
      setState(637);
      attribute();
      setState(642);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(643);
    ident();
    setState(644);
    match(WGSLParser::T__33);
    setState(645);
    type_specifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Primary_expressionContext ------------------------------------------------------------------

WGSLParser::Primary_expressionContext::Primary_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WGSLParser::IdentContext* WGSLParser::Primary_expressionContext::ident() {
  return getRuleContext<WGSLParser::IdentContext>(0);
}

WGSLParser::Template_elaborated_ident_post_identContext* WGSLParser::Primary_expressionContext::template_elaborated_ident_post_ident() {
  return getRuleContext<WGSLParser::Template_elaborated_ident_post_identContext>(0);
}

std::vector<WGSLParser::ExpressionContext *> WGSLParser::Primary_expressionContext::expression() {
  return getRuleContexts<WGSLParser::ExpressionContext>();
}

WGSLParser::ExpressionContext* WGSLParser::Primary_expressionContext::expression(size_t i) {
  return getRuleContext<WGSLParser::ExpressionContext>(i);
}

WGSLParser::LiteralContext* WGSLParser::Primary_expressionContext::literal() {
  return getRuleContext<WGSLParser::LiteralContext>(0);
}


size_t WGSLParser::Primary_expressionContext::getRuleIndex() const {
  return WGSLParser::RulePrimary_expression;
}

void WGSLParser::Primary_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimary_expression(this);
}

void WGSLParser::Primary_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimary_expression(this);
}

WGSLParser::Primary_expressionContext* WGSLParser::primary_expression() {
  Primary_expressionContext *_localctx = _tracker.createInstance<Primary_expressionContext>(_ctx, getState());
  enterRule(_localctx, 58, WGSLParser::RulePrimary_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(673);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(647);
      ident();
      setState(648);
      template_elaborated_ident_post_ident();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(650);
      ident();
      setState(651);
      template_elaborated_ident_post_ident();
      setState(652);
      match(WGSLParser::T__0);
      setState(664);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 216172782117978114) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 15811) != 0)) {
        setState(653);
        expression();
        setState(658);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(654);
            match(WGSLParser::T__1);
            setState(655);
            expression(); 
          }
          setState(660);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx);
        }
        setState(662);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WGSLParser::T__1) {
          setState(661);
          match(WGSLParser::T__1);
        }
      }
      setState(666);
      match(WGSLParser::T__2);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(668);
      literal();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(669);
      match(WGSLParser::T__0);
      setState(670);
      expression();
      setState(671);
      match(WGSLParser::T__2);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Greater_thanContext ------------------------------------------------------------------

WGSLParser::Greater_thanContext::Greater_thanContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WGSLParser::Greater_thanContext::Right_angle() {
  return getToken(WGSLParser::Right_angle, 0);
}


size_t WGSLParser::Greater_thanContext::getRuleIndex() const {
  return WGSLParser::RuleGreater_than;
}

void WGSLParser::Greater_thanContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGreater_than(this);
}

void WGSLParser::Greater_thanContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGreater_than(this);
}

WGSLParser::Greater_thanContext* WGSLParser::greater_than() {
  Greater_thanContext *_localctx = _tracker.createInstance<Greater_thanContext>(_ctx, getState());
  enterRule(_localctx, 60, WGSLParser::RuleGreater_than);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(675);
    match(WGSLParser::Right_angle);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Less_thanContext ------------------------------------------------------------------

WGSLParser::Less_thanContext::Less_thanContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* WGSLParser::Less_thanContext::Left_angle() {
  return getToken(WGSLParser::Left_angle, 0);
}


size_t WGSLParser::Less_thanContext::getRuleIndex() const {
  return WGSLParser::RuleLess_than;
}

void WGSLParser::Less_thanContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLess_than(this);
}

void WGSLParser::Less_thanContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLess_than(this);
}

WGSLParser::Less_thanContext* WGSLParser::less_than() {
  Less_thanContext *_localctx = _tracker.createInstance<Less_thanContext>(_ctx, getState());
  enterRule(_localctx, 62, WGSLParser::RuleLess_than);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(677);
    match(WGSLParser::Left_angle);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Relational_expression_post_unary_expressionContext ------------------------------------------------------------------

WGSLParser::Relational_expression_post_unary_expressionContext::Relational_expression_post_unary_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<WGSLParser::Shift_expression_post_unary_expressionContext *> WGSLParser::Relational_expression_post_unary_expressionContext::shift_expression_post_unary_expression() {
  return getRuleContexts<WGSLParser::Shift_expression_post_unary_expressionContext>();
}

WGSLParser::Shift_expression_post_unary_expressionContext* WGSLParser::Relational_expression_post_unary_expressionContext::shift_expression_post_unary_expression(size_t i) {
  return getRuleContext<WGSLParser::Shift_expression_post_unary_expressionContext>(i);
}

WGSLParser::Greater_thanContext* WGSLParser::Relational_expression_post_unary_expressionContext::greater_than() {
  return getRuleContext<WGSLParser::Greater_thanContext>(0);
}

WGSLParser::Unary_expressionContext* WGSLParser::Relational_expression_post_unary_expressionContext::unary_expression() {
  return getRuleContext<WGSLParser::Unary_expressionContext>(0);
}

tree::TerminalNode* WGSLParser::Relational_expression_post_unary_expressionContext::Greater_than_equal() {
  return getToken(WGSLParser::Greater_than_equal, 0);
}

WGSLParser::Less_thanContext* WGSLParser::Relational_expression_post_unary_expressionContext::less_than() {
  return getRuleContext<WGSLParser::Less_thanContext>(0);
}

tree::TerminalNode* WGSLParser::Relational_expression_post_unary_expressionContext::Less_than_equal() {
  return getToken(WGSLParser::Less_than_equal, 0);
}


size_t WGSLParser::Relational_expression_post_unary_expressionContext::getRuleIndex() const {
  return WGSLParser::RuleRelational_expression_post_unary_expression;
}

void WGSLParser::Relational_expression_post_unary_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelational_expression_post_unary_expression(this);
}

void WGSLParser::Relational_expression_post_unary_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelational_expression_post_unary_expression(this);
}

WGSLParser::Relational_expression_post_unary_expressionContext* WGSLParser::relational_expression_post_unary_expression() {
  Relational_expression_post_unary_expressionContext *_localctx = _tracker.createInstance<Relational_expression_post_unary_expressionContext>(_ctx, getState());
  enterRule(_localctx, 64, WGSLParser::RuleRelational_expression_post_unary_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(710);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(679);
      shift_expression_post_unary_expression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(680);
      shift_expression_post_unary_expression();
      setState(681);
      greater_than();
      setState(682);
      unary_expression();
      setState(683);
      shift_expression_post_unary_expression();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(685);
      shift_expression_post_unary_expression();
      setState(686);
      match(WGSLParser::Greater_than_equal);
      setState(687);
      unary_expression();
      setState(688);
      shift_expression_post_unary_expression();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(690);
      shift_expression_post_unary_expression();
      setState(691);
      less_than();
      setState(692);
      unary_expression();
      setState(693);
      shift_expression_post_unary_expression();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(695);
      shift_expression_post_unary_expression();
      setState(696);
      match(WGSLParser::Less_than_equal);
      setState(697);
      unary_expression();
      setState(698);
      shift_expression_post_unary_expression();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(700);
      shift_expression_post_unary_expression();
      setState(701);
      match(WGSLParser::T__43);
      setState(702);
      unary_expression();
      setState(703);
      shift_expression_post_unary_expression();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(705);
      shift_expression_post_unary_expression();
      setState(706);
      match(WGSLParser::T__44);
      setState(707);
      unary_expression();
      setState(708);
      shift_expression_post_unary_expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

WGSLParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<WGSLParser::Compound_statementContext *> WGSLParser::StatementContext::compound_statement() {
  return getRuleContexts<WGSLParser::Compound_statementContext>();
}

WGSLParser::Compound_statementContext* WGSLParser::StatementContext::compound_statement(size_t i) {
  return getRuleContext<WGSLParser::Compound_statementContext>(i);
}

std::vector<WGSLParser::AttributeContext *> WGSLParser::StatementContext::attribute() {
  return getRuleContexts<WGSLParser::AttributeContext>();
}

WGSLParser::AttributeContext* WGSLParser::StatementContext::attribute(size_t i) {
  return getRuleContext<WGSLParser::AttributeContext>(i);
}

WGSLParser::For_initContext* WGSLParser::StatementContext::for_init() {
  return getRuleContext<WGSLParser::For_initContext>(0);
}

std::vector<WGSLParser::ExpressionContext *> WGSLParser::StatementContext::expression() {
  return getRuleContexts<WGSLParser::ExpressionContext>();
}

WGSLParser::ExpressionContext* WGSLParser::StatementContext::expression(size_t i) {
  return getRuleContext<WGSLParser::ExpressionContext>(i);
}

WGSLParser::For_updateContext* WGSLParser::StatementContext::for_update() {
  return getRuleContext<WGSLParser::For_updateContext>(0);
}

std::vector<WGSLParser::StatementContext *> WGSLParser::StatementContext::statement() {
  return getRuleContexts<WGSLParser::StatementContext>();
}

WGSLParser::StatementContext* WGSLParser::StatementContext::statement(size_t i) {
  return getRuleContext<WGSLParser::StatementContext>(i);
}

tree::TerminalNode* WGSLParser::StatementContext::Break_statement() {
  return getToken(WGSLParser::Break_statement, 0);
}

std::vector<WGSLParser::Switch_clauseContext *> WGSLParser::StatementContext::switch_clause() {
  return getRuleContexts<WGSLParser::Switch_clauseContext>();
}

WGSLParser::Switch_clauseContext* WGSLParser::StatementContext::switch_clause(size_t i) {
  return getRuleContext<WGSLParser::Switch_clauseContext>(i);
}

WGSLParser::IdentContext* WGSLParser::StatementContext::ident() {
  return getRuleContext<WGSLParser::IdentContext>(0);
}

WGSLParser::Template_elaborated_ident_post_identContext* WGSLParser::StatementContext::template_elaborated_ident_post_ident() {
  return getRuleContext<WGSLParser::Template_elaborated_ident_post_identContext>(0);
}

WGSLParser::Variable_or_value_statementContext* WGSLParser::StatementContext::variable_or_value_statement() {
  return getRuleContext<WGSLParser::Variable_or_value_statementContext>(0);
}

WGSLParser::Variable_updating_statementContext* WGSLParser::StatementContext::variable_updating_statement() {
  return getRuleContext<WGSLParser::Variable_updating_statementContext>(0);
}

tree::TerminalNode* WGSLParser::StatementContext::Continue_statement() {
  return getToken(WGSLParser::Continue_statement, 0);
}


size_t WGSLParser::StatementContext::getRuleIndex() const {
  return WGSLParser::RuleStatement;
}

void WGSLParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void WGSLParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}

WGSLParser::StatementContext* WGSLParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 66, WGSLParser::RuleStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(876);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 99, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(715);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WGSLParser::T__4) {
        setState(712);
        attribute();
        setState(717);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(718);
      match(WGSLParser::T__45);
      setState(719);
      match(WGSLParser::T__0);
      setState(721);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2594073454089077762) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 65)) & 97) != 0)) {
        setState(720);
        for_init();
      }
      setState(723);
      match(WGSLParser::T__36);
      setState(725);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 216172782117978114) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 15811) != 0)) {
        setState(724);
        expression();
      }
      setState(727);
      match(WGSLParser::T__36);
      setState(729);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2305843009217888258) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 65)) & 97) != 0)) {
        setState(728);
        for_update();
      }
      setState(731);
      match(WGSLParser::T__2);
      setState(732);
      compound_statement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(736);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WGSLParser::T__4) {
        setState(733);
        attribute();
        setState(738);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(739);
      match(WGSLParser::T__46);
      setState(740);
      expression();
      setState(741);
      compound_statement();
      setState(749);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(742);
          match(WGSLParser::T__47);
          setState(743);
          match(WGSLParser::T__46);
          setState(744);
          expression();
          setState(745);
          compound_statement(); 
        }
        setState(751);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx);
      }
      setState(754);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__47) {
        setState(752);
        match(WGSLParser::T__47);
        setState(753);
        compound_statement();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(759);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WGSLParser::T__4) {
        setState(756);
        attribute();
        setState(761);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(762);
      match(WGSLParser::T__48);
      setState(766);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WGSLParser::T__4) {
        setState(763);
        attribute();
        setState(768);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(769);
      match(WGSLParser::T__28);
      setState(773);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 2628625195211949090) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 65)) & 393313) != 0)) {
        setState(770);
        statement();
        setState(775);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(798);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__49) {
        setState(776);
        match(WGSLParser::T__49);
        setState(780);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == WGSLParser::T__4) {
          setState(777);
          attribute();
          setState(782);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(783);
        match(WGSLParser::T__28);
        setState(787);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(784);
            statement(); 
          }
          setState(789);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx);
        }
        setState(795);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WGSLParser::Break_statement) {
          setState(790);
          match(WGSLParser::Break_statement);
          setState(791);
          match(WGSLParser::T__46);
          setState(792);
          expression();
          setState(793);
          match(WGSLParser::T__36);
        }
        setState(797);
        match(WGSLParser::T__29);
      }
      setState(800);
      match(WGSLParser::T__29);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(804);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WGSLParser::T__4) {
        setState(801);
        attribute();
        setState(806);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(807);
      match(WGSLParser::T__50);
      setState(808);
      expression();
      setState(812);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WGSLParser::T__4) {
        setState(809);
        attribute();
        setState(814);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(815);
      match(WGSLParser::T__28);
      setState(819);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WGSLParser::T__24

      || _la == WGSLParser::T__54) {
        setState(816);
        switch_clause();
        setState(821);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(822);
      match(WGSLParser::T__29);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(827);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == WGSLParser::T__4) {
        setState(824);
        attribute();
        setState(829);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(830);
      match(WGSLParser::T__51);
      setState(831);
      expression();
      setState(832);
      compound_statement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(834);
      compound_statement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(835);
      ident();
      setState(836);
      template_elaborated_ident_post_ident();
      setState(837);
      match(WGSLParser::T__0);
      setState(849);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 216172782117978114) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 15811) != 0)) {
        setState(838);
        expression();
        setState(843);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(839);
            match(WGSLParser::T__1);
            setState(840);
            expression(); 
          }
          setState(845);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 95, _ctx);
        }
        setState(847);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WGSLParser::T__1) {
          setState(846);
          match(WGSLParser::T__1);
        }
      }
      setState(851);
      match(WGSLParser::T__2);
      setState(852);
      match(WGSLParser::T__36);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(854);
      variable_or_value_statement();
      setState(855);
      match(WGSLParser::T__36);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(857);
      variable_updating_statement();
      setState(858);
      match(WGSLParser::T__36);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(860);
      match(WGSLParser::Break_statement);
      setState(861);
      match(WGSLParser::T__36);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(862);
      match(WGSLParser::Continue_statement);
      setState(863);
      match(WGSLParser::T__36);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(864);
      match(WGSLParser::T__36);
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(865);
      match(WGSLParser::T__38);
      setState(866);
      expression();
      setState(867);
      match(WGSLParser::T__36);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(869);
      match(WGSLParser::T__52);
      setState(870);
      match(WGSLParser::T__36);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(871);
      match(WGSLParser::T__53);
      setState(873);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 216172782117978114) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 64)) & 15811) != 0)) {
        setState(872);
        expression();
      }
      setState(875);
      match(WGSLParser::T__36);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Switch_clauseContext ------------------------------------------------------------------

WGSLParser::Switch_clauseContext::Switch_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<WGSLParser::Case_selectorContext *> WGSLParser::Switch_clauseContext::case_selector() {
  return getRuleContexts<WGSLParser::Case_selectorContext>();
}

WGSLParser::Case_selectorContext* WGSLParser::Switch_clauseContext::case_selector(size_t i) {
  return getRuleContext<WGSLParser::Case_selectorContext>(i);
}

WGSLParser::Compound_statementContext* WGSLParser::Switch_clauseContext::compound_statement() {
  return getRuleContext<WGSLParser::Compound_statementContext>(0);
}


size_t WGSLParser::Switch_clauseContext::getRuleIndex() const {
  return WGSLParser::RuleSwitch_clause;
}

void WGSLParser::Switch_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSwitch_clause(this);
}

void WGSLParser::Switch_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSwitch_clause(this);
}

WGSLParser::Switch_clauseContext* WGSLParser::switch_clause() {
  Switch_clauseContext *_localctx = _tracker.createInstance<Switch_clauseContext>(_ctx, getState());
  enterRule(_localctx, 68, WGSLParser::RuleSwitch_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(900);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case WGSLParser::T__54: {
        enterOuterAlt(_localctx, 1);
        setState(878);
        match(WGSLParser::T__54);
        setState(879);
        case_selector();
        setState(884);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(880);
            match(WGSLParser::T__1);
            setState(881);
            case_selector(); 
          }
          setState(886);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx);
        }
        setState(888);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WGSLParser::T__1) {
          setState(887);
          match(WGSLParser::T__1);
        }
        setState(891);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WGSLParser::T__33) {
          setState(890);
          match(WGSLParser::T__33);
        }
        setState(893);
        compound_statement();
        break;
      }

      case WGSLParser::T__24: {
        enterOuterAlt(_localctx, 2);
        setState(895);
        match(WGSLParser::T__24);
        setState(897);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WGSLParser::T__33) {
          setState(896);
          match(WGSLParser::T__33);
        }
        setState(899);
        compound_statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Template_arg_expressionContext ------------------------------------------------------------------

WGSLParser::Template_arg_expressionContext::Template_arg_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WGSLParser::ExpressionContext* WGSLParser::Template_arg_expressionContext::expression() {
  return getRuleContext<WGSLParser::ExpressionContext>(0);
}


size_t WGSLParser::Template_arg_expressionContext::getRuleIndex() const {
  return WGSLParser::RuleTemplate_arg_expression;
}

void WGSLParser::Template_arg_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemplate_arg_expression(this);
}

void WGSLParser::Template_arg_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemplate_arg_expression(this);
}

WGSLParser::Template_arg_expressionContext* WGSLParser::template_arg_expression() {
  Template_arg_expressionContext *_localctx = _tracker.createInstance<Template_arg_expressionContext>(_ctx, getState());
  enterRule(_localctx, 70, WGSLParser::RuleTemplate_arg_expression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(902);
    expression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Template_elaborated_ident_post_identContext ------------------------------------------------------------------

WGSLParser::Template_elaborated_ident_post_identContext::Template_elaborated_ident_post_identContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WGSLParser::Template_args_startContext* WGSLParser::Template_elaborated_ident_post_identContext::template_args_start() {
  return getRuleContext<WGSLParser::Template_args_startContext>(0);
}

WGSLParser::Template_arg_expressionContext* WGSLParser::Template_elaborated_ident_post_identContext::template_arg_expression() {
  return getRuleContext<WGSLParser::Template_arg_expressionContext>(0);
}

WGSLParser::Template_args_endContext* WGSLParser::Template_elaborated_ident_post_identContext::template_args_end() {
  return getRuleContext<WGSLParser::Template_args_endContext>(0);
}

std::vector<WGSLParser::ExpressionContext *> WGSLParser::Template_elaborated_ident_post_identContext::expression() {
  return getRuleContexts<WGSLParser::ExpressionContext>();
}

WGSLParser::ExpressionContext* WGSLParser::Template_elaborated_ident_post_identContext::expression(size_t i) {
  return getRuleContext<WGSLParser::ExpressionContext>(i);
}


size_t WGSLParser::Template_elaborated_ident_post_identContext::getRuleIndex() const {
  return WGSLParser::RuleTemplate_elaborated_ident_post_ident;
}

void WGSLParser::Template_elaborated_ident_post_identContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemplate_elaborated_ident_post_ident(this);
}

void WGSLParser::Template_elaborated_ident_post_identContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemplate_elaborated_ident_post_ident(this);
}

WGSLParser::Template_elaborated_ident_post_identContext* WGSLParser::template_elaborated_ident_post_ident() {
  Template_elaborated_ident_post_identContext *_localctx = _tracker.createInstance<Template_elaborated_ident_post_identContext>(_ctx, getState());
  enterRule(_localctx, 72, WGSLParser::RuleTemplate_elaborated_ident_post_ident);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(918);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx)) {
    case 1: {
      setState(904);
      template_args_start();
      setState(905);
      template_arg_expression();
      setState(910);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 105, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(906);
          match(WGSLParser::T__1);
          setState(907);
          expression(); 
        }
        setState(912);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 105, _ctx);
      }
      setState(914);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__1) {
        setState(913);
        match(WGSLParser::T__1);
      }
      setState(916);
      template_args_end();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Translation_unitContext ------------------------------------------------------------------

WGSLParser::Translation_unitContext::Translation_unitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<WGSLParser::Global_directiveContext *> WGSLParser::Translation_unitContext::global_directive() {
  return getRuleContexts<WGSLParser::Global_directiveContext>();
}

WGSLParser::Global_directiveContext* WGSLParser::Translation_unitContext::global_directive(size_t i) {
  return getRuleContext<WGSLParser::Global_directiveContext>(i);
}

std::vector<WGSLParser::Global_declContext *> WGSLParser::Translation_unitContext::global_decl() {
  return getRuleContexts<WGSLParser::Global_declContext>();
}

WGSLParser::Global_declContext* WGSLParser::Translation_unitContext::global_decl(size_t i) {
  return getRuleContext<WGSLParser::Global_declContext>(i);
}

std::vector<WGSLParser::StatementContext *> WGSLParser::Translation_unitContext::statement() {
  return getRuleContexts<WGSLParser::StatementContext>();
}

WGSLParser::StatementContext* WGSLParser::Translation_unitContext::statement(size_t i) {
  return getRuleContext<WGSLParser::StatementContext>(i);
}


size_t WGSLParser::Translation_unitContext::getRuleIndex() const {
  return WGSLParser::RuleTranslation_unit;
}

void WGSLParser::Translation_unitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTranslation_unit(this);
}

void WGSLParser::Translation_unitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTranslation_unit(this);
}

WGSLParser::Translation_unitContext* WGSLParser::translation_unit() {
  Translation_unitContext *_localctx = _tracker.createInstance<Translation_unitContext>(_ctx, getState());
  enterRule(_localctx, 74, WGSLParser::RuleTranslation_unit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(923);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6597069768704) != 0)) {
      setState(920);
      global_directive();
      setState(925);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(929);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(926);
        global_decl(); 
      }
      setState(931);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx);
    }
    setState(935);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2628625195211949090) != 0) || ((((_la - 65) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 65)) & 393313) != 0)) {
      setState(932);
      statement();
      setState(937);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_specifierContext ------------------------------------------------------------------

WGSLParser::Type_specifierContext::Type_specifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WGSLParser::IdentContext* WGSLParser::Type_specifierContext::ident() {
  return getRuleContext<WGSLParser::IdentContext>(0);
}

WGSLParser::Template_args_startContext* WGSLParser::Type_specifierContext::template_args_start() {
  return getRuleContext<WGSLParser::Template_args_startContext>(0);
}

WGSLParser::Template_arg_expressionContext* WGSLParser::Type_specifierContext::template_arg_expression() {
  return getRuleContext<WGSLParser::Template_arg_expressionContext>(0);
}

WGSLParser::Template_args_endContext* WGSLParser::Type_specifierContext::template_args_end() {
  return getRuleContext<WGSLParser::Template_args_endContext>(0);
}

std::vector<WGSLParser::ExpressionContext *> WGSLParser::Type_specifierContext::expression() {
  return getRuleContexts<WGSLParser::ExpressionContext>();
}

WGSLParser::ExpressionContext* WGSLParser::Type_specifierContext::expression(size_t i) {
  return getRuleContext<WGSLParser::ExpressionContext>(i);
}


size_t WGSLParser::Type_specifierContext::getRuleIndex() const {
  return WGSLParser::RuleType_specifier;
}

void WGSLParser::Type_specifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_specifier(this);
}

void WGSLParser::Type_specifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_specifier(this);
}

WGSLParser::Type_specifierContext* WGSLParser::type_specifier() {
  Type_specifierContext *_localctx = _tracker.createInstance<Type_specifierContext>(_ctx, getState());
  enterRule(_localctx, 76, WGSLParser::RuleType_specifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(938);
    ident();
    setState(953);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == WGSLParser::Left_angle) {
      setState(939);
      template_args_start();
      setState(940);
      template_arg_expression();
      setState(945);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(941);
          match(WGSLParser::T__1);
          setState(942);
          expression(); 
        }
        setState(947);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx);
      }
      setState(949);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__1) {
        setState(948);
        match(WGSLParser::T__1);
      }
      setState(951);
      template_args_end();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unary_expressionContext ------------------------------------------------------------------

WGSLParser::Unary_expressionContext::Unary_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WGSLParser::Primary_expressionContext* WGSLParser::Unary_expressionContext::primary_expression() {
  return getRuleContext<WGSLParser::Primary_expressionContext>(0);
}

WGSLParser::Component_or_swizzle_specifierContext* WGSLParser::Unary_expressionContext::component_or_swizzle_specifier() {
  return getRuleContext<WGSLParser::Component_or_swizzle_specifierContext>(0);
}

WGSLParser::Unary_expressionContext* WGSLParser::Unary_expressionContext::unary_expression() {
  return getRuleContext<WGSLParser::Unary_expressionContext>(0);
}

tree::TerminalNode* WGSLParser::Unary_expressionContext::Star() {
  return getToken(WGSLParser::Star, 0);
}

tree::TerminalNode* WGSLParser::Unary_expressionContext::Minus() {
  return getToken(WGSLParser::Minus, 0);
}


size_t WGSLParser::Unary_expressionContext::getRuleIndex() const {
  return WGSLParser::RuleUnary_expression;
}

void WGSLParser::Unary_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnary_expression(this);
}

void WGSLParser::Unary_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnary_expression(this);
}

WGSLParser::Unary_expressionContext* WGSLParser::unary_expression() {
  Unary_expressionContext *_localctx = _tracker.createInstance<Unary_expressionContext>(_ctx, getState());
  enterRule(_localctx, 78, WGSLParser::RuleUnary_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(969);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case WGSLParser::T__0:
      case WGSLParser::Sigma_term:
      case WGSLParser::Ident_pattern_token:
      case WGSLParser::Bool_literal:
      case WGSLParser::Decimal_float_literal:
      case WGSLParser::Decimal_int_literal:
      case WGSLParser::Hex_float_literal:
      case WGSLParser::Hex_int_literal: {
        enterOuterAlt(_localctx, 1);
        setState(955);
        primary_expression();
        setState(957);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == WGSLParser::T__25

        || _la == WGSLParser::T__26) {
          setState(956);
          component_or_swizzle_specifier();
        }
        break;
      }

      case WGSLParser::T__55: {
        enterOuterAlt(_localctx, 2);
        setState(959);
        match(WGSLParser::T__55);
        setState(960);
        unary_expression();
        break;
      }

      case WGSLParser::T__21: {
        enterOuterAlt(_localctx, 3);
        setState(961);
        match(WGSLParser::T__21);
        setState(962);
        unary_expression();
        break;
      }

      case WGSLParser::Star: {
        enterOuterAlt(_localctx, 4);
        setState(963);
        match(WGSLParser::Star);
        setState(964);
        unary_expression();
        break;
      }

      case WGSLParser::Minus: {
        enterOuterAlt(_localctx, 5);
        setState(965);
        match(WGSLParser::Minus);
        setState(966);
        unary_expression();
        break;
      }

      case WGSLParser::T__56: {
        enterOuterAlt(_localctx, 6);
        setState(967);
        match(WGSLParser::T__56);
        setState(968);
        unary_expression();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_declContext ------------------------------------------------------------------

WGSLParser::Variable_declContext::Variable_declContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WGSLParser::Optionally_typed_identContext* WGSLParser::Variable_declContext::optionally_typed_ident() {
  return getRuleContext<WGSLParser::Optionally_typed_identContext>(0);
}

WGSLParser::Template_args_startContext* WGSLParser::Variable_declContext::template_args_start() {
  return getRuleContext<WGSLParser::Template_args_startContext>(0);
}

std::vector<WGSLParser::ExpressionContext *> WGSLParser::Variable_declContext::expression() {
  return getRuleContexts<WGSLParser::ExpressionContext>();
}

WGSLParser::ExpressionContext* WGSLParser::Variable_declContext::expression(size_t i) {
  return getRuleContext<WGSLParser::ExpressionContext>(i);
}

WGSLParser::Template_args_endContext* WGSLParser::Variable_declContext::template_args_end() {
  return getRuleContext<WGSLParser::Template_args_endContext>(0);
}


size_t WGSLParser::Variable_declContext::getRuleIndex() const {
  return WGSLParser::RuleVariable_decl;
}

void WGSLParser::Variable_declContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_decl(this);
}

void WGSLParser::Variable_declContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_decl(this);
}

WGSLParser::Variable_declContext* WGSLParser::variable_decl() {
  Variable_declContext *_localctx = _tracker.createInstance<Variable_declContext>(_ctx, getState());
  enterRule(_localctx, 80, WGSLParser::RuleVariable_decl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(971);
    match(WGSLParser::T__35);
    setState(986);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == WGSLParser::Left_angle) {
      setState(972);
      template_args_start();
      setState(973);
      expression();
      setState(978);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(974);
          match(WGSLParser::T__1);
          setState(975);
          expression(); 
        }
        setState(980);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx);
      }
      setState(982);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == WGSLParser::T__1) {
        setState(981);
        match(WGSLParser::T__1);
      }
      setState(984);
      template_args_end();
    }
    setState(988);
    optionally_typed_ident();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_or_value_statementContext ------------------------------------------------------------------

WGSLParser::Variable_or_value_statementContext::Variable_or_value_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WGSLParser::Variable_declContext* WGSLParser::Variable_or_value_statementContext::variable_decl() {
  return getRuleContext<WGSLParser::Variable_declContext>(0);
}

WGSLParser::ExpressionContext* WGSLParser::Variable_or_value_statementContext::expression() {
  return getRuleContext<WGSLParser::ExpressionContext>(0);
}

WGSLParser::Optionally_typed_identContext* WGSLParser::Variable_or_value_statementContext::optionally_typed_ident() {
  return getRuleContext<WGSLParser::Optionally_typed_identContext>(0);
}


size_t WGSLParser::Variable_or_value_statementContext::getRuleIndex() const {
  return WGSLParser::RuleVariable_or_value_statement;
}

void WGSLParser::Variable_or_value_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_or_value_statement(this);
}

void WGSLParser::Variable_or_value_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_or_value_statement(this);
}

WGSLParser::Variable_or_value_statementContext* WGSLParser::variable_or_value_statement() {
  Variable_or_value_statementContext *_localctx = _tracker.createInstance<Variable_or_value_statementContext>(_ctx, getState());
  enterRule(_localctx, 82, WGSLParser::RuleVariable_or_value_statement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1005);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 119, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(990);
      variable_decl();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(991);
      variable_decl();
      setState(992);
      match(WGSLParser::T__3);
      setState(993);
      expression();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(995);
      match(WGSLParser::T__9);
      setState(996);
      optionally_typed_ident();
      setState(997);
      match(WGSLParser::T__3);
      setState(998);
      expression();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1000);
      match(WGSLParser::T__57);
      setState(1001);
      optionally_typed_ident();
      setState(1002);
      match(WGSLParser::T__3);
      setState(1003);
      expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Variable_updating_statementContext ------------------------------------------------------------------

WGSLParser::Variable_updating_statementContext::Variable_updating_statementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

WGSLParser::Lhs_expressionContext* WGSLParser::Variable_updating_statementContext::lhs_expression() {
  return getRuleContext<WGSLParser::Lhs_expressionContext>(0);
}

WGSLParser::ExpressionContext* WGSLParser::Variable_updating_statementContext::expression() {
  return getRuleContext<WGSLParser::ExpressionContext>(0);
}

tree::TerminalNode* WGSLParser::Variable_updating_statementContext::Compound_assignment_operator() {
  return getToken(WGSLParser::Compound_assignment_operator, 0);
}


size_t WGSLParser::Variable_updating_statementContext::getRuleIndex() const {
  return WGSLParser::RuleVariable_updating_statement;
}

void WGSLParser::Variable_updating_statementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable_updating_statement(this);
}

void WGSLParser::Variable_updating_statementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<WGSLListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable_updating_statement(this);
}

WGSLParser::Variable_updating_statementContext* WGSLParser::variable_updating_statement() {
  Variable_updating_statementContext *_localctx = _tracker.createInstance<Variable_updating_statementContext>(_ctx, getState());
  enterRule(_localctx, 84, WGSLParser::RuleVariable_updating_statement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1020);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1007);
      lhs_expression();
      setState(1008);
      _la = _input->LA(1);
      if (!(_la == WGSLParser::T__3 || _la == WGSLParser::Compound_assignment_operator)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1009);
      expression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1011);
      lhs_expression();
      setState(1012);
      match(WGSLParser::T__58);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1014);
      lhs_expression();
      setState(1015);
      match(WGSLParser::T__59);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1017);
      match(WGSLParser::T__60);
      setState(1018);
      match(WGSLParser::T__3);
      setState(1019);
      expression();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

void WGSLParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  wgslParserInitialize();
#else
  ::antlr4::internal::call_once(wgslParserOnceFlag, wgslParserInitialize);
#endif
}
